This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
.opencode/
  agent/
    agent-creator.md
    jj-manager.md
cmd/
  archive_test.go
  archive.go
  root_test.go
  root.go
internal/
  core/
    db/
      migrations/
        0001-init.sql
        0002-archive.sql
      archives_test.go
      archives.go
      bookmarks_test.go
      bookmarks.go
      db_test.go
      db.go
      events_test.go
      events.go
      models.go
    web/
      static/
        app.css
      templates/
        archive_item.html
        archives_list.html
        archives.html
        bookmarklet_add.html
        bookmarklet.html
        bookmarks.html
        index.html
        nav.html
        viewer.html
      handlers_archives.go
      handlers_bookmarks.go
      handlers_test.go
      handlers.go
      server_test.go
      server.go
      views.go
    archive_test.go
    archive.go
    constants.go
    inline_test.go
    inline.go
.gitignore
CLAUDE.md
go.mod
justfile
LICENSE
main.go
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(go test:*)",
      "Bash(go build:*)"
    ]
  }
}
</file>

<file path=".opencode/agent/agent-creator.md">
---
description: Creates and configures OpenCode agents with best practices
mode: subagent
temperature: 0.3
tools:
  write: true
  edit: true
  bash: false
  webfetch: true
---

You are an expert at creating OpenCode agents. Your job is to help users design and implement custom agents for their specific workflows.

## Your Responsibilities

1. **Understand the use case** - Ask clarifying questions about what the agent should do
2. **Design the agent** - Determine the appropriate mode, tools, permissions, and prompt
3. **Create the agent file** - Write a well-structured markdown agent file

## Agent Creation Guidelines

### Choosing the Mode
- Use `primary` for main agents users interact with directly (switchable via Tab)
- Use `subagent` for specialized tasks that primary agents can invoke
- Use `all` if the agent should work in both contexts

### Configuring Tools
Disable tools the agent doesn't need:
- `write: false` - Prevents creating new files
- `edit: false` - Prevents modifying existing files  
- `bash: false` - Prevents running shell commands
- `webfetch: false` - Prevents fetching web content

### Setting Permissions
For sensitive operations, use permissions:
- `ask` - Prompt for approval before running
- `allow` - Allow without approval
- `deny` - Completely disable

### Temperature Settings
- 0.0-0.2: Deterministic, ideal for code analysis
- 0.3-0.5: Balanced, good for general tasks
- 0.6-1.0: Creative, useful for brainstorming

### Writing Effective Prompts
- Be specific about the agent's role and expertise
- List concrete focus areas or responsibilities
- Include constraints and guidelines
- Provide examples if helpful

## File Locations
- Global agents: `~/.config/opencode/agent/`
- Project agents: `.opencode/agent/`

## Output Format
When creating an agent, always output a complete markdown file with:
1. YAML frontmatter with all necessary configuration
2. A clear, focused system prompt

Ask clarifying questions before creating the agent to ensure it meets the user's needs.
</file>

<file path=".opencode/agent/jj-manager.md">
---
description: Manages Jujutsu (jj) version control operations - a Git-compatible VCS with automatic commits and powerful history rewriting
mode: primary
temperature: 0.2
tools:
  write: false
  edit: false
  bash: true
  webfetch: false
---

You are an expert Jujutsu (jj) version control assistant. Jujutsu is a modern, Git-compatible VCS that fundamentally differs from Git in its approach to version control. Your role is to help users effectively use jj for all their version control needs.

## Core Jujutsu Concepts

### The Working Copy Model
- **No staging area**: The working copy IS a commit (the "working copy commit")
- **Automatic snapshotting**: Changes are automatically recorded - no need to `git add`
- **`@` symbol**: Always refers to the current working copy commit
- **Anonymous commits**: Commits don't need messages until you're ready

### Key Terminology
- **Change**: A logical unit of work (has a stable change ID even when rebased)
- **Commit**: A specific version (commit ID changes on rebase, change ID doesn't)
- **Revision**: Either a change or commit, selected via revsets
- **Bookmark**: jj's equivalent of Git branches (pointers to commits)

## Essential Commands Reference

### Status & Inspection
```bash
jj status              # Show working copy status
jj log                 # Show commit history (default: all visible commits)
jj log -r 'revset'     # Show specific revisions
jj diff                # Show changes in working copy
jj diff -r REV         # Show changes in a specific revision
jj show REV            # Show a commit's details and diff
```

### Creating & Managing Changes
```bash
jj new                 # Create new empty commit on top of @
jj new REV             # Create new commit on top of REV
jj new REV1 REV2       # Create merge commit with multiple parents
jj commit -m "msg"     # Describe @ and create new empty commit on top
jj describe -m "msg"   # Set/update description of @ (or -r REV)
jj edit REV            # Switch working copy to edit an existing commit
jj abandon REV         # Remove a commit (descendants are rebased)
```

### History Rewriting
```bash
jj rebase -r REV -d DEST       # Rebase single commit to new destination
jj rebase -s REV -d DEST       # Rebase commit and descendants
jj rebase -b REV -d DEST       # Rebase entire branch
jj squash                      # Squash @ into parent
jj squash -r REV               # Squash REV into its parent
jj squash --into DEST          # Squash @ into specific commit
jj split -r REV                # Interactively split a commit
jj diffedit -r REV             # Edit a commit's changes interactively
jj restore --from REV          # Restore files from another revision
jj restore --from REV PATH     # Restore specific path from revision
```

### Bookmarks (Branches)
```bash
jj bookmark list                    # List all bookmarks
jj bookmark create NAME             # Create bookmark at @
jj bookmark create NAME -r REV      # Create bookmark at REV
jj bookmark move NAME               # Move bookmark to @
jj bookmark move NAME -r REV        # Move bookmark to REV
jj bookmark delete NAME             # Delete a bookmark
jj bookmark track NAME@remote       # Track a remote bookmark
```

### Git Interoperability
```bash
jj git clone URL [PATH]        # Clone a Git repository
jj git fetch                   # Fetch from all remotes
jj git fetch --remote NAME     # Fetch from specific remote
jj git push                    # Push current bookmark
jj git push -b NAME            # Push specific bookmark
jj git push --all              # Push all bookmarks
jj git init --colocate         # Initialize jj in existing Git repo
```

### Conflict Handling
```bash
jj status                      # Shows conflicts if present
jj resolve                     # Launch merge tool for conflicts
jj resolve --list              # List conflicted files
# Conflicts are stored IN commits - you can continue working and resolve later
```

### Operation Log & Undo
```bash
jj op log                      # Show operation history
jj undo                        # Undo the last operation
jj op restore OPID             # Restore to a specific operation
jj op diff OPID1 OPID2         # Compare two operations
```

## Revset Language

Revsets are jj's powerful way to select commits. Common patterns:

### Basic Selectors
- `@` - Working copy commit
- `@-` - Parent of working copy
- `@--` or `@-2` - Grandparent
- `root()` - The root commit
- `trunk()` - Main branch (main/master)
- `bookmarks()` - All bookmarked commits
- `remote_bookmarks()` - All remote bookmarks
- `heads()` - All head commits
- `visible_heads()` - Visible head commits

### Operators
- `x & y` - Intersection (and)
- `x | y` - Union (or)
- `~x` - Negation (not)
- `x..y` - Commits reachable from y but not x (DAG range)
- `x::y` - x to y inclusive
- `::x` - Ancestors of x (inclusive)
- `x::` - Descendants of x (inclusive)

### Functions
- `ancestors(x)` - All ancestors of x
- `descendants(x)` - All descendants of x
- `parents(x)` - Direct parents of x
- `children(x)` - Direct children of x
- `connected(x)` - x and all commits between
- `reachable(x, y)` - Commits reachable from x within y
- `description(pattern)` - Commits matching description
- `author(pattern)` - Commits by author
- `committer(pattern)` - Commits by committer
- `empty()` - Empty commits
- `conflict()` - Commits with conflicts
- `mine()` - Your commits

### Example Revsets
```bash
jj log -r '@::'                    # Working copy and descendants
jj log -r '::@ & ~::trunk()'       # Commits on current branch not in trunk
jj log -r 'bookmarks() & mine()'   # My bookmarked commits
jj log -r 'trunk()..@'             # Commits between trunk and @
jj log -r 'conflict()'             # All commits with conflicts
jj rebase -s 'roots(trunk()..@)' -d trunk()  # Rebase branch onto trunk
```

## Common Workflows

### Starting New Work
```bash
jj new trunk()                 # Start from trunk
jj describe -m "feat: new feature"
# ... make changes (automatically tracked)
jj new                         # Start next logical change
```

### Updating a Branch
```bash
jj git fetch
jj rebase -b @ -d trunk()      # Rebase your work onto updated trunk
```

### Preparing for Push
```bash
jj log -r 'trunk()..@'         # Review commits to push
jj bookmark move my-feature    # Ensure bookmark is at @
jj git push -b my-feature
```

### Fixing a Previous Commit
```bash
jj edit @-                     # Edit the parent commit
# ... make fixes
jj new                         # Or: jj edit @ to return
```

### Squashing Work in Progress
```bash
jj squash                      # Squash @ into parent
# Or squash specific commits:
jj squash -r REV --into DEST
```

## Guidelines

1. **Always check status first**: Run `jj status` to understand current state
2. **Use `jj log` liberally**: The log shows the full picture of your repo
3. **Prefer change IDs**: Use change IDs (short hex) over commit IDs for stability
4. **Leverage revsets**: Learn revsets to efficiently select commits
5. **Don't fear history rewriting**: jj makes it safe with operation log
6. **Use `jj undo` freely**: Every operation can be undone
7. **Explain the model**: Help users understand jj's unique approach vs Git

## Safety Notes

- Always run `jj status` before destructive operations
- Use `jj op log` to review recent operations if something seems wrong
- Remember `jj undo` can reverse almost any operation
- Be careful with `jj git push --force` (same risks as Git)
- Conflicts in jj are stored in commits - they won't block your work

When helping users, explain jj's model when relevant, suggest appropriate revsets, and leverage the operation log for debugging issues.
</file>

<file path="cmd/archive_test.go">
/*
Copyright © 2025 Katie Mulliken <katie@mulliken.net>
*/
package cmd

import (
	"bytes"
	"runtime"
	"testing"
	"time"
)

func TestArchiveCmd_Flags(t *testing.T) {
	tests := []struct {
		name         string
		flagName     string
		defaultValue interface{}
		flagType     string
	}{
		{
			name:         "id flag has correct default",
			flagName:     "id",
			defaultValue: int64(0),
			flagType:     "int64",
		},
		{
			name:         "limit flag has correct default",
			flagName:     "limit",
			defaultValue: 0,
			flagType:     "int",
		},
		{
			name:         "timeout flag has correct default",
			flagName:     "timeout",
			defaultValue: 40 * time.Second,
			flagType:     "duration",
		},
		{
			name:         "wait-selector flag has correct default",
			flagName:     "wait-selector",
			defaultValue: "",
			flagType:     "string",
		},
		{
			name:         "chrome-path flag has correct default",
			flagName:     "chrome-path",
			defaultValue: "",
			flagType:     "string",
		},
		{
			name:         "headful flag has correct default",
			flagName:     "headful",
			defaultValue: false,
			flagType:     "bool",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var flag interface{}
			var err error

			switch tt.flagType {
			case "string":
				flag, err = archiveCmd.Flags().GetString(tt.flagName)
			case "int":
				flag, err = archiveCmd.Flags().GetInt(tt.flagName)
			case "int64":
				flag, err = archiveCmd.Flags().GetInt64(tt.flagName)
			case "bool":
				flag, err = archiveCmd.Flags().GetBool(tt.flagName)
			case "duration":
				flag, err = archiveCmd.Flags().GetDuration(tt.flagName)
			}

			if err != nil {
				t.Fatalf("Failed to get flag %s: %v", tt.flagName, err)
			}

			if flag != tt.defaultValue {
				t.Errorf("Flag %s: got %v, want %v", tt.flagName, flag, tt.defaultValue)
			}
		})
	}
}

func TestArchiveCmd_CommandMetadata(t *testing.T) {
	if archiveCmd.Use != "archive" {
		t.Errorf("Expected Use to be 'archive', got %s", archiveCmd.Use)
	}

	if archiveCmd.Short == "" {
		t.Error("Expected Short description to be set")
	}
}

func TestArchiveCmd_UsageOutput(t *testing.T) {
	var buf bytes.Buffer
	archiveCmd.SetOut(&buf)
	archiveCmd.SetErr(&buf)

	err := archiveCmd.Usage()
	if err != nil {
		t.Errorf("Usage() returned error: %v", err)
	}

	output := buf.String()
	if output == "" {
		t.Error("Expected usage output, got empty string")
	}

	// Check that key flags are mentioned in usage
	expectedFlags := []string{"--id", "--limit", "--timeout", "--chrome-path", "--headful"}
	for _, flag := range expectedFlags {
		if !bytes.Contains([]byte(output), []byte(flag)) {
			t.Errorf("Expected usage to mention %s", flag)
		}
	}
}

func TestArchiveCmd_InheritsDBFlag(t *testing.T) {
	// The archive command should have access to the persistent --db flag from root
	flag := archiveCmd.InheritedFlags().Lookup("db")
	if flag == nil {
		t.Error("Expected archive command to inherit --db flag from root")
	}
}

func TestArchiveCmd_ChromePathDefault_Darwin(t *testing.T) {
	if runtime.GOOS != "darwin" {
		t.Skip("Skipping macOS-specific test")
	}

	// On macOS, when chrome-path is empty, it should default to the standard Chrome location
	// This is tested indirectly through the runArchive logic
	chromePath, _ := archiveCmd.Flags().GetString("chrome-path")
	if chromePath != "" {
		t.Errorf("Expected default chrome-path to be empty (runtime detection), got %s", chromePath)
	}
}

func TestArchiveCmd_HeadlessDefault(t *testing.T) {
	// By default, headful should be false (meaning headless mode is enabled)
	headful, err := archiveCmd.Flags().GetBool("headful")
	if err != nil {
		t.Fatalf("Failed to get headful flag: %v", err)
	}

	if headful {
		t.Error("Expected headful to default to false (headless mode)")
	}
}

func TestArchiveCmd_FlagShortcuts(t *testing.T) {
	// Verify that expected flag shortcuts exist
	// Note: archive command doesn't define shortcuts, but we verify the flags exist
	flags := archiveCmd.Flags()

	requiredFlags := []string{"id", "limit", "timeout", "wait-selector", "chrome-path", "headful"}
	for _, name := range requiredFlags {
		if flags.Lookup(name) == nil {
			t.Errorf("Expected flag %s to be defined", name)
		}
	}
}
</file>

<file path="cmd/archive.go">
/*
Copyright © 2025 Katie Mulliken <katie@mulliken.net>
*/

// The archive command provides functionality to archive (scrape and store) bookmarks in the database.
//
// Features:
//   - Archive a single bookmark by specifying its ID.
//   - Archive multiple bookmarks by limiting the number processed.
//   - Customize the Chrome/Chromium executable path used for scraping.
//   - Choose between headless or headful Chrome execution.
//   - Configure a timeout for each archive job.
//   - Wait for a specified CSS selector before scraping, helpful for dynamic JS-rendered pages.
//
// Example usage:
//
//	bookmarkd archive --id=123 --limit=5 --timeout=30s --wait-selector=".loading-indicator" --chrome-path="/path/to/chrome" --headful
//	bookmarkd archive --limit=10 --headless
package cmd

import (
	"context"
	"fmt"
	"log"
	"runtime"
	"time"

	"github.com/seckatie/bookmarkd/internal/core"
	"github.com/spf13/cobra"
)

// archiveCmd represents the archive command
var archiveCmd = &cobra.Command{
	Use:   "archive",
	Short: "Archive (scrape) bookmarks into the database",
	Run: func(cmd *cobra.Command, args []string) {
		if err := runArchive(cmd); err != nil {
			log.Fatalf("Archive failed: %v", err)
		}
	},
}

// runArchive is the main function for the archive command.
func runArchive(cmd *cobra.Command) error {
	db, err := initDB(cmd)
	if err != nil {
		return fmt.Errorf("failed to initialize database: %w", err)
	}
	defer func() {
		if err := db.Close(); err != nil {
			log.Printf("failed to close database: %v", err)
		}
	}()

	id, err := cmd.Flags().GetInt64("id")
	if err != nil {
		return fmt.Errorf("failed to read --id: %w", err)
	}
	limit, err := cmd.Flags().GetInt("limit")
	if err != nil {
		return fmt.Errorf("failed to read --limit: %w", err)
	}
	timeout, err := cmd.Flags().GetDuration("timeout")
	if err != nil {
		return fmt.Errorf("failed to read --timeout: %w", err)
	}
	waitSelector, err := cmd.Flags().GetString("wait-selector")
	if err != nil {
		return fmt.Errorf("failed to read --wait-selector: %w", err)
	}
	chromePath, err := cmd.Flags().GetString("chrome-path")
	if err != nil {
		return fmt.Errorf("failed to read --chrome-path: %w", err)
	}
	headful, err := cmd.Flags().GetBool("headful")
	if err != nil {
		return fmt.Errorf("failed to read --headful: %w", err)
	}

	if chromePath == "" && runtime.GOOS == "darwin" {
		// Best-effort default for macOS.
		chromePath = "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"
	}

	opts := core.ArchiveOptions{
		ChromePath:   chromePath,
		Headless:     !headful,
		Timeout:      timeout,
		WaitSelector: waitSelector,
	}

	ctx := context.Background()

	if id > 0 {
		b, err := db.GetBookmark(id)
		if err != nil {
			return err
		}
		return core.ArchiveAndPersist(ctx, db, b, opts)
	}

	bookmarks, err := db.ListBookmarksToArchive(limit)
	if err != nil {
		return err
	}
	if len(bookmarks) == 0 {
		log.Println("No bookmarks to archive.")
		return nil
	}

	log.Printf("Archiving %d bookmark(s)...", len(bookmarks))
	var failures int
	for _, b := range bookmarks {
		if err := core.ArchiveAndPersist(ctx, db, b, opts); err != nil {
			failures++
			log.Printf("Archive failed for id=%d url=%s: %v", b.ID, b.URL, err)
		}
	}
	if failures > 0 {
		return fmt.Errorf("archiving finished with %d failure(s)", failures)
	}

	log.Println("Archiving finished successfully.")
	return nil
}

func init() {
	rootCmd.AddCommand(archiveCmd)

	archiveCmd.Flags().Int64("id", 0, "Archive a specific bookmark id")
	archiveCmd.Flags().Int("limit", 0, "Limit the number of bookmarks to archive (0 = all unarchived)")
	archiveCmd.Flags().Duration("timeout", 40*time.Second, "Per-bookmark archive timeout")
	archiveCmd.Flags().String("wait-selector", "", "Optional CSS selector to wait for (useful for JS-heavy pages)")
	archiveCmd.Flags().String("chrome-path", "", "Path to Chrome/Chromium executable")
	archiveCmd.Flags().Bool("headful", false, "Run Chrome with a visible window (not headless)")
}
</file>

<file path="cmd/root_test.go">
/*
Copyright © 2025 Katie Mulliken <katie@mulliken.net>
*/
package cmd

import (
	"bytes"
	"testing"
)

func TestRootCmd_Flags(t *testing.T) {
	tests := []struct {
		name         string
		flagName     string
		defaultValue interface{}
		flagType     string
	}{
		{
			name:         "db flag has correct default",
			flagName:     "db",
			defaultValue: "bookmarkd.db",
			flagType:     "string",
		},
		{
			name:         "port flag has correct default",
			flagName:     "port",
			defaultValue: 8080,
			flagType:     "int",
		},
		{
			name:         "host flag has correct default",
			flagName:     "host",
			defaultValue: "localhost",
			flagType:     "string",
		},
		{
			name:         "archive-workers flag has correct default",
			flagName:     "archive-workers",
			defaultValue: 1,
			flagType:     "int",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var flag interface{}
			var err error

			switch tt.flagType {
			case "string":
				if tt.flagName == "db" {
					flag, err = rootCmd.PersistentFlags().GetString(tt.flagName)
				} else {
					flag, err = rootCmd.Flags().GetString(tt.flagName)
				}
			case "int":
				flag, err = rootCmd.Flags().GetInt(tt.flagName)
			}

			if err != nil {
				t.Fatalf("Failed to get flag %s: %v", tt.flagName, err)
			}

			if flag != tt.defaultValue {
				t.Errorf("Flag %s: got %v, want %v", tt.flagName, flag, tt.defaultValue)
			}
		})
	}
}

func TestRootCmd_HasArchiveSubcommand(t *testing.T) {
	found := false
	for _, cmd := range rootCmd.Commands() {
		if cmd.Use == "archive" {
			found = true
			break
		}
	}

	if !found {
		t.Error("Expected archive subcommand to be registered")
	}
}

func TestRootCmd_UsageOutput(t *testing.T) {
	var buf bytes.Buffer
	rootCmd.SetOut(&buf)
	rootCmd.SetErr(&buf)

	// Test that usage doesn't error
	err := rootCmd.Usage()
	if err != nil {
		t.Errorf("Usage() returned error: %v", err)
	}

	output := buf.String()
	if output == "" {
		t.Error("Expected usage output, got empty string")
	}
}

func TestRootCmd_CommandMetadata(t *testing.T) {
	if rootCmd.Use != "bookmarkd" {
		t.Errorf("Expected Use to be 'bookmarkd', got %s", rootCmd.Use)
	}

	if rootCmd.Short == "" {
		t.Error("Expected Short description to be set")
	}

	if rootCmd.Long == "" {
		t.Error("Expected Long description to be set")
	}
}
</file>

<file path="internal/core/db/migrations/0001-init.sql">
-- bookmarkd initial schema migration

CREATE TABLE IF NOT EXISTS bookmarks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    url TEXT NOT NULL,
    title TEXT NOT NULL,
    created_at TEXT NOT NULL
);
</file>

<file path="internal/core/db/migrations/0002-archive.sql">
-- Add fields for archiving/scraping bookmark pages

ALTER TABLE bookmarks ADD COLUMN archived_html TEXT;
ALTER TABLE bookmarks ADD COLUMN archived_url TEXT;
ALTER TABLE bookmarks ADD COLUMN archive_attempted_at TEXT;
ALTER TABLE bookmarks ADD COLUMN archived_at TEXT;
ALTER TABLE bookmarks ADD COLUMN archive_status TEXT;
ALTER TABLE bookmarks ADD COLUMN archive_error TEXT;
</file>

<file path="internal/core/db/archives_test.go">
package db

import (
	"strings"
	"testing"
	"time"
)

// TestListBookmarksToArchive tests listing bookmarks that need archiving.
func TestListBookmarksToArchive(t *testing.T) {
	db := newTestDB(t)
	t.Cleanup(func() {
		if err := db.Close(); err != nil {
			t.Errorf("failed to close db: %v", err)
		}
	})

	t.Run("returns all unarchived bookmarks", func(t *testing.T) {
		if _, err := db.AddBookmark("https://site1.com", "Site 1"); err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}
		if _, err := db.AddBookmark("https://site2.com", "Site 2"); err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}

		bookmarks, err := db.ListBookmarksToArchive(0)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if len(bookmarks) != 2 {
			t.Errorf("expected 2 bookmarks to archive, got %d", len(bookmarks))
		}
	})

	t.Run("excludes archived bookmarks", func(t *testing.T) {
		// Create a fresh database
		db2 := newTestDB(t)
		t.Cleanup(func() {
			if err := db2.Close(); err != nil {
				t.Errorf("failed to close db2: %v", err)
			}
		})

		id1, err := db2.AddBookmark("https://archived.com", "Archived")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}
		if _, err := db2.AddBookmark("https://unarchived.com", "Unarchived"); err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}

		// Archive the first one
		now := time.Now()
		if err := db2.SaveArchiveResult(id1, now, &now, "ok", "", "https://archived.com", "<html></html>"); err != nil {
			t.Fatalf("failed to save archive result: %v", err)
		}

		bookmarks, err := db2.ListBookmarksToArchive(0)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if len(bookmarks) != 1 {
			t.Errorf("expected 1 bookmark to archive, got %d", len(bookmarks))
		}
		if bookmarks[0].URL != "https://unarchived.com" {
			t.Errorf("expected unarchived bookmark, got %q", bookmarks[0].URL)
		}
	})

	t.Run("respects limit", func(t *testing.T) {
		db3 := newTestDB(t)
		t.Cleanup(func() {
			if err := db3.Close(); err != nil {
				t.Errorf("failed to close db3: %v", err)
			}
		})

		if _, err := db3.AddBookmark("https://site1.com", "Site 1"); err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}
		if _, err := db3.AddBookmark("https://site2.com", "Site 2"); err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}
		if _, err := db3.AddBookmark("https://site3.com", "Site 3"); err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}

		bookmarks, err := db3.ListBookmarksToArchive(2)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if len(bookmarks) != 2 {
			t.Errorf("expected 2 bookmarks with limit, got %d", len(bookmarks))
		}
	})
}

// TestListArchivedBookmarks tests listing successfully archived bookmarks.
func TestListArchivedBookmarks(t *testing.T) {
	db := newTestDB(t)
	t.Cleanup(func() {
		if err := db.Close(); err != nil {
			t.Errorf("failed to close db: %v", err)
		}
	})

	t.Run("returns only archived bookmarks", func(t *testing.T) {
		id1, err := db.AddBookmark("https://archived.com", "Archived")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}
		if _, err := db.AddBookmark("https://unarchived.com", "Unarchived"); err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}

		now := time.Now()
		if err := db.SaveArchiveResult(id1, now, &now, "ok", "", "https://archived.com", "<html></html>"); err != nil {
			t.Fatalf("failed to save archive result: %v", err)
		}

		bookmarks, err := db.ListArchivedBookmarks(0)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if len(bookmarks) != 1 {
			t.Errorf("expected 1 archived bookmark, got %d", len(bookmarks))
		}
		if bookmarks[0].URL != "https://archived.com" {
			t.Errorf("expected archived bookmark, got %q", bookmarks[0].URL)
		}
	})

	t.Run("respects limit", func(t *testing.T) {
		db2 := newTestDB(t)
		t.Cleanup(func() {
			if err := db2.Close(); err != nil {
				t.Errorf("failed to close db2: %v", err)
			}
		})

		id1, err := db2.AddBookmark("https://site1.com", "Site 1")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}
		id2, err := db2.AddBookmark("https://site2.com", "Site 2")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}
		id3, err := db2.AddBookmark("https://site3.com", "Site 3")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}

		now := time.Now()
		if err := db2.SaveArchiveResult(id1, now, &now, "ok", "", "", "<html>1</html>"); err != nil {
			t.Fatalf("failed to save archive result: %v", err)
		}
		if err := db2.SaveArchiveResult(id2, now, &now, "ok", "", "", "<html>2</html>"); err != nil {
			t.Fatalf("failed to save archive result: %v", err)
		}
		if err := db2.SaveArchiveResult(id3, now, &now, "ok", "", "", "<html>3</html>"); err != nil {
			t.Fatalf("failed to save archive result: %v", err)
		}

		bookmarks, err := db2.ListArchivedBookmarks(2)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if len(bookmarks) != 2 {
			t.Errorf("expected 2 archived bookmarks, got %d", len(bookmarks))
		}
	})
}

// TestListBookmarksByArchiveStatus tests filtering by archive status.
func TestListBookmarksByArchiveStatus(t *testing.T) {
	db := newTestDB(t)
	t.Cleanup(func() {
		if err := db.Close(); err != nil {
			t.Errorf("failed to close db: %v", err)
		}
	})

	id1, err := db.AddBookmark("https://success.com", "Success")
	if err != nil {
		t.Fatalf("failed to add bookmark: %v", err)
	}
	id2, err := db.AddBookmark("https://error.com", "Error")
	if err != nil {
		t.Fatalf("failed to add bookmark: %v", err)
	}
	if _, err := db.AddBookmark("https://pending.com", "Pending"); err != nil {
		t.Fatalf("failed to add bookmark: %v", err)
	}

	now := time.Now()
	if err := db.SaveArchiveResult(id1, now, &now, "ok", "", "", "<html></html>"); err != nil {
		t.Fatalf("failed to save archive result: %v", err)
	}
	if err := db.SaveArchiveResult(id2, now, nil, "error", "connection timeout", "", ""); err != nil {
		t.Fatalf("failed to save archive result: %v", err)
	}

	t.Run("filters by ok status", func(t *testing.T) {
		bookmarks, err := db.ListBookmarksByArchiveStatus("ok", 0)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if len(bookmarks) != 1 {
			t.Errorf("expected 1 bookmark with ok status, got %d", len(bookmarks))
		}
		if bookmarks[0].URL != "https://success.com" {
			t.Errorf("expected success bookmark, got %q", bookmarks[0].URL)
		}
	})

	t.Run("filters by error status", func(t *testing.T) {
		bookmarks, err := db.ListBookmarksByArchiveStatus("error", 0)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if len(bookmarks) != 1 {
			t.Errorf("expected 1 bookmark with error status, got %d", len(bookmarks))
		}
		if bookmarks[0].URL != "https://error.com" {
			t.Errorf("expected error bookmark, got %q", bookmarks[0].URL)
		}
	})
}

// TestGetBookmarkArchive tests retrieving archive data.
func TestGetBookmarkArchive(t *testing.T) {
	db := newTestDB(t)
	t.Cleanup(func() {
		if err := db.Close(); err != nil {
			t.Errorf("failed to close db: %v", err)
		}
	})

	t.Run("retrieves archive for existing bookmark", func(t *testing.T) {
		id, err := db.AddBookmark("https://example.com", "Example")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}

		now := time.Now()
		html := "<html><body>Hello</body></html>"
		if err := db.SaveArchiveResult(id, now, &now, "ok", "", "https://example.com/final", html); err != nil {
			t.Fatalf("failed to save archive result: %v", err)
		}

		archive, err := db.GetBookmarkArchive(id)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if archive.BookmarkID != id {
			t.Errorf("expected BookmarkID %d, got %d", id, archive.BookmarkID)
		}
		if archive.ArchiveStatus != "ok" {
			t.Errorf("expected status 'ok', got %q", archive.ArchiveStatus)
		}
		if archive.ArchivedURL != "https://example.com/final" {
			t.Errorf("expected archived URL, got %q", archive.ArchivedURL)
		}
		if archive.ArchivedHTML != html {
			t.Errorf("expected HTML content, got %q", archive.ArchivedHTML)
		}
	})

	t.Run("returns empty fields for unarchived bookmark", func(t *testing.T) {
		id, err := db.AddBookmark("https://new.com", "New")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}

		archive, err := db.GetBookmarkArchive(id)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if archive.ArchiveStatus != "" {
			t.Errorf("expected empty status, got %q", archive.ArchiveStatus)
		}
		if archive.ArchivedHTML != "" {
			t.Errorf("expected empty HTML, got %q", archive.ArchivedHTML)
		}
	})

	t.Run("returns error for non-existent bookmark", func(t *testing.T) {
		_, err := db.GetBookmarkArchive(99999)
		if err == nil {
			t.Error("expected error for non-existent bookmark")
		}
		if !strings.Contains(err.Error(), "not found") {
			t.Errorf("expected 'not found' error, got %v", err)
		}
	})
}

// TestSaveArchiveResult tests saving archive results.
func TestSaveArchiveResult(t *testing.T) {
	db := newTestDB(t)
	t.Cleanup(func() {
		if err := db.Close(); err != nil {
			t.Errorf("failed to close db: %v", err)
		}
	})

	t.Run("saves successful archive", func(t *testing.T) {
		id, err := db.AddBookmark("https://example.com", "Example")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}

		attemptedAt := time.Now()
		archivedAt := attemptedAt.Add(5 * time.Second)
		html := "<html></html>"

		err = db.SaveArchiveResult(id, attemptedAt, &archivedAt, "ok", "", "https://example.com", html)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}

		archive, _ := db.GetBookmarkArchive(id)
		if archive.ArchiveStatus != "ok" {
			t.Errorf("expected status 'ok', got %q", archive.ArchiveStatus)
		}
		if archive.ArchiveError != "" {
			t.Errorf("expected no error, got %q", archive.ArchiveError)
		}
	})

	t.Run("saves failed archive", func(t *testing.T) {
		id, err := db.AddBookmark("https://fail.com", "Fail")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}

		attemptedAt := time.Now()
		errMsg := "connection refused"

		err = db.SaveArchiveResult(id, attemptedAt, nil, "error", errMsg, "", "")
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}

		archive, _ := db.GetBookmarkArchive(id)
		if archive.ArchiveStatus != "error" {
			t.Errorf("expected status 'error', got %q", archive.ArchiveStatus)
		}
		if archive.ArchiveError != errMsg {
			t.Errorf("expected error %q, got %q", errMsg, archive.ArchiveError)
		}
		if archive.ArchivedAt != "" {
			t.Errorf("expected empty archived_at for failed archive, got %q", archive.ArchivedAt)
		}
	})

	t.Run("returns error for non-existent bookmark", func(t *testing.T) {
		err := db.SaveArchiveResult(99999, time.Now(), nil, "ok", "", "", "")
		if err == nil {
			t.Error("expected error for non-existent bookmark")
		}
		if !strings.Contains(err.Error(), "not found") {
			t.Errorf("expected 'not found' error, got %v", err)
		}
	})
}

// TestClearBookmarkArchive tests clearing archive data.
func TestClearBookmarkArchive(t *testing.T) {
	db := newTestDB(t)
	t.Cleanup(func() {
		if err := db.Close(); err != nil {
			t.Errorf("failed to close db: %v", err)
		}
	})

	t.Run("clears existing archive", func(t *testing.T) {
		id, err := db.AddBookmark("https://example.com", "Example")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}

		now := time.Now()
		if err := db.SaveArchiveResult(id, now, &now, "ok", "", "https://example.com", "<html></html>"); err != nil {
			t.Fatalf("failed to save archive result: %v", err)
		}

		err = db.ClearBookmarkArchive(id)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}

		archive, _ := db.GetBookmarkArchive(id)
		if archive.ArchiveStatus != "" {
			t.Errorf("expected empty status after clear, got %q", archive.ArchiveStatus)
		}
		if archive.ArchivedHTML != "" {
			t.Errorf("expected empty HTML after clear, got %q", archive.ArchivedHTML)
		}
	})

	t.Run("returns error for non-existent bookmark", func(t *testing.T) {
		err := db.ClearBookmarkArchive(99999)
		if err == nil {
			t.Error("expected error for non-existent bookmark")
		}
		if !strings.Contains(err.Error(), "not found") {
			t.Errorf("expected 'not found' error, got %v", err)
		}
	})
}

// TestQueueBookmarkForArchive tests queueing a bookmark for archive.
func TestQueueBookmarkForArchive(t *testing.T) {
	db := newTestDB(t)
	t.Cleanup(func() {
		if err := db.Close(); err != nil {
			t.Errorf("failed to close db: %v", err)
		}
	})

	t.Run("queues archived bookmark for re-archive", func(t *testing.T) {
		id, err := db.AddBookmark("https://example.com", "Example")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}

		now := time.Now()
		if err := db.SaveArchiveResult(id, now, &now, "ok", "", "", "<html></html>"); err != nil {
			t.Fatalf("failed to save archive result: %v", err)
		}

		// Verify it's archived
		archived, err := db.ListArchivedBookmarks(0)
		if err != nil {
			t.Fatalf("failed to list archived bookmarks: %v", err)
		}
		if len(archived) != 1 {
			t.Fatalf("expected 1 archived bookmark, got %d", len(archived))
		}

		// Queue for re-archive
		err = db.QueueBookmarkForArchive(id)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}

		// Should now appear in "to archive" list
		toArchive, err := db.ListBookmarksToArchive(0)
		if err != nil {
			t.Fatalf("failed to list bookmarks to archive: %v", err)
		}
		if len(toArchive) != 1 {
			t.Errorf("expected 1 bookmark to archive after queue, got %d", len(toArchive))
		}
	})
}
</file>

<file path="internal/core/db/db_test.go">
package db

import (
	"os"
	"testing"
	"time"
)

// newTestDB creates a new in-memory SQLite database for testing.
// It runs migrations and returns the DB instance.
func newTestDB(t *testing.T) *DB {
	t.Helper()
	db, err := NewSQLiteDB(":memory:")
	if err != nil {
		t.Fatalf("failed to create test database: %v", err)
	}
	if err := db.Migrate(); err != nil {
		t.Fatalf("failed to migrate test database: %v", err)
	}
	return db
}

// TestNewSQLiteDB tests database creation.
func TestNewSQLiteDB(t *testing.T) {
	t.Run("in-memory database", func(t *testing.T) {
		db, err := NewSQLiteDB(":memory:")
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		defer db.Close()

		if db.db == nil {
			t.Error("expected db.db to be non-nil")
		}
		if db.eventListeners == nil {
			t.Error("expected eventListeners to be initialized")
		}
	})

	t.Run("file database", func(t *testing.T) {
		tmpFile, err := os.CreateTemp("", "bookmarkd-test-*.db")
		if err != nil {
			t.Fatalf("failed to create temp file: %v", err)
		}
		if err := tmpFile.Close(); err != nil {
			t.Fatalf("failed to close temp file: %v", err)
		}
		t.Cleanup(func() {
			if err := os.Remove(tmpFile.Name()); err != nil {
				t.Errorf("failed to remove temp file: %v", err)
			}
		})

		db, err := NewSQLiteDB(tmpFile.Name())
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		defer db.Close()

		if db.db == nil {
			t.Error("expected db.db to be non-nil")
		}
	})
}

// TestMigrate tests the migration system.
func TestMigrate(t *testing.T) {
	t.Run("applies migrations successfully", func(t *testing.T) {
		db, err := NewSQLiteDB(":memory:")
		if err != nil {
			t.Fatalf("failed to create database: %v", err)
		}
		defer db.Close()

		if err := db.Migrate(); err != nil {
			t.Fatalf("expected no error, got %v", err)
		}

		// Verify schema_migrations table exists and has entries
		var count int
		err = db.db.QueryRow("SELECT COUNT(*) FROM schema_migrations").Scan(&count)
		if err != nil {
			t.Fatalf("failed to query schema_migrations: %v", err)
		}
		if count == 0 {
			t.Error("expected migrations to be recorded")
		}
	})

	t.Run("migrations are idempotent", func(t *testing.T) {
		db, err := NewSQLiteDB(":memory:")
		if err != nil {
			t.Fatalf("failed to create database: %v", err)
		}
		defer db.Close()

		// Run migrations twice
		if err := db.Migrate(); err != nil {
			t.Fatalf("first migration failed: %v", err)
		}
		if err := db.Migrate(); err != nil {
			t.Fatalf("second migration failed: %v", err)
		}

		// Verify bookmarks table exists by inserting a row
		_, err = db.db.Exec("INSERT INTO bookmarks (url, title, created_at) VALUES (?, ?, ?)",
			"https://example.com", "Test", time.Now().Format(time.RFC3339))
		if err != nil {
			t.Fatalf("failed to insert into bookmarks: %v", err)
		}
	})
}

// TestClose tests database close functionality.
func TestClose(t *testing.T) {
	db, err := NewSQLiteDB(":memory:")
	if err != nil {
		t.Fatalf("failed to create database: %v", err)
	}

	if err := db.Close(); err != nil {
		t.Fatalf("expected no error, got %v", err)
	}

	// Verify database is closed by attempting a query
	_, err = db.db.Exec("SELECT 1")
	if err == nil {
		t.Error("expected error after close, got nil")
	}
}
</file>

<file path="internal/core/db/db.go">
package db

import (
	"database/sql"
	"embed"
	"fmt"
	"log"
	"sort"
	"strings"

	_ "github.com/mattn/go-sqlite3"
)

//go:embed migrations/*.sql
var migrationsFS embed.FS

type DB struct {
	db             *sql.DB
	eventListeners map[EventKind][]EventListener
}

func NewSQLiteDB(path string) (*DB, error) {
	db, err := sql.Open("sqlite3", path)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}
	return &DB{
		db:             db,
		eventListeners: make(map[EventKind][]EventListener),
	}, nil
}

func (db *DB) Migrate() error {
	// Create migrations tracking table if it doesn't exist
	_, err := db.db.Exec(`
		CREATE TABLE IF NOT EXISTS schema_migrations (
			version VARCHAR(255) PRIMARY KEY,
			applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
		)
	`)
	if err != nil {
		return fmt.Errorf("failed to create schema migrations table: %w", err)
	}

	entries, err := migrationsFS.ReadDir("migrations")
	if err != nil {
		return fmt.Errorf("failed to read migrations directory: %w", err)
	}

	var migrations []string
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		if !strings.HasSuffix(entry.Name(), ".sql") {
			continue
		}
		migrations = append(migrations, entry.Name())
	}

	sort.Strings(migrations)

	for _, migration := range migrations {
		version := strings.TrimSuffix(migration, ".sql")
		if version == "" {
			log.Println("Invalid migration file name:", migration)
			continue
		}

		// Check if migration has already been applied
		var exists bool
		if err := db.db.QueryRow(`
		    SELECT EXISTS (SELECT 1 FROM schema_migrations WHERE version = ?)
		`, version).Scan(&exists); err != nil {
			return fmt.Errorf("failed to check if migration has been applied: %w", err)
		}
		if exists {
			log.Printf("Migration %s has already been applied, skipping...", version)
			continue
		}

		// Apply migration
		content, err := migrationsFS.ReadFile("migrations/" + migration)
		if err != nil {
			return fmt.Errorf("failed to read migration file: %w", err)
		}

		tx, err := db.db.Begin()
		if err != nil {
			return fmt.Errorf("failed to begin transaction: %w", err)
		}

		if _, err := tx.Exec(string(content)); err != nil {
			if rbErr := tx.Rollback(); rbErr != nil {
				log.Printf("failed to rollback transaction: %v", rbErr)
			}
			return fmt.Errorf("failed to apply migration %s: %w", version, err)
		}

		// Mark migration as applied
		if _, err := tx.Exec(`
		    INSERT INTO schema_migrations (version) VALUES (?)
		`, version); err != nil {
			if rbErr := tx.Rollback(); rbErr != nil {
				log.Printf("failed to rollback transaction: %v", rbErr)
			}
			return fmt.Errorf("failed to mark migration as applied: %w", err)
		}

		if err := tx.Commit(); err != nil {
			return fmt.Errorf("failed to commit transaction: %w", err)
		}

		log.Printf("Migration %s applied successfully", version)
	}

	return nil
}

func (db *DB) Close() error {
	return db.db.Close()
}
</file>

<file path="internal/core/db/events_test.go">
package db

import (
	"errors"
	"testing"
	"time"
)

// TestEventKindString tests the String method on EventKind.
func TestEventKindString(t *testing.T) {
	tests := []struct {
		kind     EventKind
		expected string
	}{
		{OnBookmarkCreatedEvent, "bookmark_created"},
		{OnBookmarkDeletedEvent, "bookmark_deleted"},
		{OnBookmarkUpdatedEvent, "bookmark_updated"},
		{OnArchiveResultSavedEvent, "archive_result_saved"},
		{OnArchiveClearedEvent, "archive_cleared"},
		{EventKind(999), "unknown"},
	}

	for _, tt := range tests {
		t.Run(tt.expected, func(t *testing.T) {
			if got := tt.kind.String(); got != tt.expected {
				t.Errorf("expected %q, got %q", tt.expected, got)
			}
		})
	}
}

// TestEventTypes tests that event types return correct Kind.
func TestEventTypes(t *testing.T) {
	t.Run("BookmarkCreatedEvent", func(t *testing.T) {
		e := BookmarkCreatedEvent{Bookmark: Bookmark{ID: 1}}
		if e.Kind() != OnBookmarkCreatedEvent {
			t.Errorf("expected OnBookmarkCreatedEvent, got %v", e.Kind())
		}
	})

	t.Run("BookmarkUpdatedEvent", func(t *testing.T) {
		e := BookmarkUpdatedEvent{Bookmark: Bookmark{ID: 1}}
		if e.Kind() != OnBookmarkUpdatedEvent {
			t.Errorf("expected OnBookmarkUpdatedEvent, got %v", e.Kind())
		}
	})

	t.Run("BookmarkDeletedEvent", func(t *testing.T) {
		e := BookmarkDeletedEvent{Bookmark: Bookmark{ID: 1}}
		if e.Kind() != OnBookmarkDeletedEvent {
			t.Errorf("expected OnBookmarkDeletedEvent, got %v", e.Kind())
		}
	})

	t.Run("ArchiveResultSavedEvent", func(t *testing.T) {
		e := ArchiveResultSavedEvent{BookmarkID: 1, Status: "ok"}
		if e.Kind() != OnArchiveResultSavedEvent {
			t.Errorf("expected OnArchiveResultSavedEvent, got %v", e.Kind())
		}
	})

	t.Run("ArchiveClearedEvent", func(t *testing.T) {
		e := ArchiveClearedEvent{BookmarkID: 1}
		if e.Kind() != OnArchiveClearedEvent {
			t.Errorf("expected OnArchiveClearedEvent, got %v", e.Kind())
		}
	})
}

// TestRegisterEventListener tests listener registration.
func TestRegisterEventListener(t *testing.T) {
	db := newTestDB(t)
	defer db.Close()

	called := false
	db.RegisterEventListener(OnBookmarkCreatedEvent, func(event Event) error {
		called = true
		return nil
	})

	db.AddBookmark("https://example.com", "Test")

	if !called {
		t.Error("expected listener to be called")
	}
}

// TestBookmarkCreatedEvent tests that event is emitted on bookmark creation.
func TestBookmarkCreatedEvent(t *testing.T) {
	db := newTestDB(t)
	defer db.Close()

	var receivedEvent BookmarkCreatedEvent
	db.RegisterEventListener(OnBookmarkCreatedEvent, func(event Event) error {
		receivedEvent = event.(BookmarkCreatedEvent)
		return nil
	})

	id, _ := db.AddBookmark("https://example.com", "Test Site")

	if receivedEvent.Bookmark.ID != id {
		t.Errorf("expected bookmark ID %d, got %d", id, receivedEvent.Bookmark.ID)
	}
	if receivedEvent.Bookmark.URL != "https://example.com" {
		t.Errorf("expected URL 'https://example.com', got %q", receivedEvent.Bookmark.URL)
	}
	if receivedEvent.Bookmark.Title != "Test Site" {
		t.Errorf("expected Title 'Test Site', got %q", receivedEvent.Bookmark.Title)
	}
}

// TestBookmarkUpdatedEvent tests that event is emitted on bookmark update.
func TestBookmarkUpdatedEvent(t *testing.T) {
	db := newTestDB(t)
	defer db.Close()

	id, _ := db.AddBookmark("https://old.com", "Old Title")

	var receivedEvent BookmarkUpdatedEvent
	db.RegisterEventListener(OnBookmarkUpdatedEvent, func(event Event) error {
		receivedEvent = event.(BookmarkUpdatedEvent)
		return nil
	})

	if err := db.UpdateBookmark(id, "https://new.com", "New Title"); err != nil {
		t.Fatalf("failed to update bookmark: %v", err)
	}

	if receivedEvent.Bookmark.ID != id {
		t.Errorf("expected bookmark ID %d, got %d", id, receivedEvent.Bookmark.ID)
	}
	if receivedEvent.Bookmark.URL != "https://new.com" {
		t.Errorf("expected URL 'https://new.com', got %q", receivedEvent.Bookmark.URL)
	}
}

// TestBookmarkDeletedEvent tests that event is emitted on bookmark deletion.
func TestBookmarkDeletedEvent(t *testing.T) {
	db := newTestDB(t)
	defer db.Close()

	id, _ := db.AddBookmark("https://example.com", "To Delete")

	var receivedEvent BookmarkDeletedEvent
	db.RegisterEventListener(OnBookmarkDeletedEvent, func(event Event) error {
		receivedEvent = event.(BookmarkDeletedEvent)
		return nil
	})

	if err := db.DeleteBookmark(id); err != nil {
		t.Fatalf("failed to delete bookmark: %v", err)
	}

	if receivedEvent.Bookmark.ID != id {
		t.Errorf("expected bookmark ID %d, got %d", id, receivedEvent.Bookmark.ID)
	}
}

// TestArchiveResultSavedEvent tests that event is emitted when archive result is saved.
func TestArchiveResultSavedEvent(t *testing.T) {
	db := newTestDB(t)
	defer db.Close()

	id, _ := db.AddBookmark("https://example.com", "Test")

	var receivedEvent ArchiveResultSavedEvent
	db.RegisterEventListener(OnArchiveResultSavedEvent, func(event Event) error {
		receivedEvent = event.(ArchiveResultSavedEvent)
		return nil
	})

	now := time.Now()
	if err := db.SaveArchiveResult(id, now, &now, "ok", "", "", "<html></html>"); err != nil {
		t.Fatalf("failed to save archive result: %v", err)
	}

	if receivedEvent.BookmarkID != id {
		t.Errorf("expected bookmark ID %d, got %d", id, receivedEvent.BookmarkID)
	}
	if receivedEvent.Status != "ok" {
		t.Errorf("expected status 'ok', got %q", receivedEvent.Status)
	}
}

// TestArchiveClearedEvent tests that event is emitted when archive is cleared.
func TestArchiveClearedEvent(t *testing.T) {
	db := newTestDB(t)
	defer db.Close()

	id, err := db.AddBookmark("https://example.com", "Test")
	if err != nil {
		t.Fatalf("failed to add bookmark: %v", err)
	}
	now := time.Now()
	if err := db.SaveArchiveResult(id, now, &now, "ok", "", "", "<html></html>"); err != nil {
		t.Fatalf("failed to save archive result: %v", err)
	}

	var receivedEvent ArchiveClearedEvent
	db.RegisterEventListener(OnArchiveClearedEvent, func(event Event) error {
		receivedEvent = event.(ArchiveClearedEvent)
		return nil
	})

	if err := db.ClearBookmarkArchive(id); err != nil {
		t.Fatalf("failed to clear bookmark archive: %v", err)
	}

	if receivedEvent.BookmarkID != id {
		t.Errorf("expected bookmark ID %d, got %d", id, receivedEvent.BookmarkID)
	}
}

// TestMultipleListeners tests that multiple listeners are called.
func TestMultipleListeners(t *testing.T) {
	db := newTestDB(t)
	defer db.Close()

	callCount := 0

	db.RegisterEventListener(OnBookmarkCreatedEvent, func(event Event) error {
		callCount++
		return nil
	})
	db.RegisterEventListener(OnBookmarkCreatedEvent, func(event Event) error {
		callCount++
		return nil
	})

	db.AddBookmark("https://example.com", "Test")

	if callCount != 2 {
		t.Errorf("expected 2 listeners to be called, got %d", callCount)
	}
}

// TestListenerErrors tests that listener errors are handled gracefully.
func TestListenerErrors(t *testing.T) {
	db := newTestDB(t)
	defer db.Close()

	secondCalled := false

	db.RegisterEventListener(OnBookmarkCreatedEvent, func(event Event) error {
		return errors.New("first listener error")
	})
	db.RegisterEventListener(OnBookmarkCreatedEvent, func(event Event) error {
		secondCalled = true
		return nil
	})

	// Should not panic and should continue to next listener
	id, err := db.AddBookmark("https://example.com", "Test")
	if err != nil {
		t.Fatalf("expected no error from AddBookmark, got %v", err)
	}
	if id <= 0 {
		t.Error("expected valid bookmark ID")
	}
	if !secondCalled {
		t.Error("expected second listener to be called despite first listener error")
	}
}

// TestListenersForDifferentEvents tests that listeners only receive their event type.
func TestListenersForDifferentEvents(t *testing.T) {
	db := newTestDB(t)
	defer db.Close()

	createdCalled := false
	deletedCalled := false

	db.RegisterEventListener(OnBookmarkCreatedEvent, func(event Event) error {
		createdCalled = true
		return nil
	})
	db.RegisterEventListener(OnBookmarkDeletedEvent, func(event Event) error {
		deletedCalled = true
		return nil
	})

	// Only create a bookmark, don't delete
	db.AddBookmark("https://example.com", "Test")

	if !createdCalled {
		t.Error("expected created listener to be called")
	}
	if deletedCalled {
		t.Error("expected deleted listener NOT to be called")
	}
}
</file>

<file path="internal/core/db/events.go">
package db

import "log"

// ------------------------------
// Event System
// ------------------------------
//
// The DB emits typed events when bookmarks are created, updated, deleted,
// or when archive results are saved. Register listeners to react to these changes.
//
// Example usage:
//
//	db.RegisterEventListener(db.OnBookmarkCreatedEvent, func(event db.Event) error {
//	    ev := event.(db.BookmarkCreatedEvent)
//	    log.Printf("New bookmark created: %d - %s", ev.Bookmark.ID, ev.Bookmark.URL)
//	    // Optionally queue an archive job here
//	    return nil
//	})
//
//	db.RegisterEventListener(db.OnBookmarkUpdatedEvent, func(event db.Event) error {
//	    ev := event.(db.BookmarkUpdatedEvent)
//	    log.Printf("Bookmark updated: %d", ev.Bookmark.ID)
//	    return nil
//	})
//
// Event is the common interface for all database events.
type Event interface {
	Kind() EventKind
}

// EventKind represents all the kinds of events that can be emitted by the DB.
type EventKind int

const (
	// OnBookmarkCreatedEvent is emitted when a bookmark is created.
	OnBookmarkCreatedEvent EventKind = iota
	// OnBookmarkDeletedEvent is emitted when a bookmark is deleted.
	OnBookmarkDeletedEvent
	// OnBookmarkUpdatedEvent is emitted when a bookmark is updated.
	OnBookmarkUpdatedEvent
	// OnArchiveResultSavedEvent is emitted when an archive result is saved.
	OnArchiveResultSavedEvent
	// OnArchiveClearedEvent is emitted when an archive is cleared for re-archiving.
	OnArchiveClearedEvent
)

func (k EventKind) String() string {
	switch k {
	case OnBookmarkCreatedEvent:
		return "bookmark_created"
	case OnBookmarkDeletedEvent:
		return "bookmark_deleted"
	case OnBookmarkUpdatedEvent:
		return "bookmark_updated"
	case OnArchiveResultSavedEvent:
		return "archive_result_saved"
	case OnArchiveClearedEvent:
		return "archive_cleared"
	default:
		return "unknown"
	}
}

// BookmarkCreatedEvent is emitted after a new bookmark is successfully inserted.
type BookmarkCreatedEvent struct {
	Bookmark Bookmark
}

func (e BookmarkCreatedEvent) Kind() EventKind { return OnBookmarkCreatedEvent }

// BookmarkUpdatedEvent is emitted after a bookmark's URL or title is updated.
type BookmarkUpdatedEvent struct {
	Bookmark Bookmark
}

func (e BookmarkUpdatedEvent) Kind() EventKind { return OnBookmarkUpdatedEvent }

// BookmarkDeletedEvent is emitted after a bookmark is deleted.
// The Bookmark field contains the state before deletion (if available).
type BookmarkDeletedEvent struct {
	Bookmark Bookmark
}

func (e BookmarkDeletedEvent) Kind() EventKind { return OnBookmarkDeletedEvent }

// ArchiveResultSavedEvent is emitted after an archive result is saved.
type ArchiveResultSavedEvent struct {
	BookmarkID int64
	Status     string // "ok" or "error"
}

func (e ArchiveResultSavedEvent) Kind() EventKind { return OnArchiveResultSavedEvent }

// ArchiveClearedEvent is emitted after an archive is cleared for re-archiving.
type ArchiveClearedEvent struct {
	BookmarkID int64
}

func (e ArchiveClearedEvent) Kind() EventKind { return OnArchiveClearedEvent }

// EventListener is a callback that handles events of a specific kind.
type EventListener func(event Event) error

// RegisterEventListener adds a listener for a specific event kind.
// Listeners are called synchronously in registration order after the DB operation succeeds.
func (db *DB) RegisterEventListener(eventKind EventKind, listener EventListener) {
	if db.eventListeners == nil {
		db.eventListeners = make(map[EventKind][]EventListener)
	}
	db.eventListeners[eventKind] = append(db.eventListeners[eventKind], listener)
}

// emit dispatches an event to all registered listeners for that event kind.
func (db *DB) emit(event Event) {
	listeners := db.eventListeners[event.Kind()]
	for _, listener := range listeners {
		if err := listener(event); err != nil {
			log.Printf("Event listener error for %s: %v", event.Kind(), err)
		}
	}
}
</file>

<file path="internal/core/db/models.go">
package db

type Bookmark struct {
	ID    int64
	URL   string
	Title string
	// CreatedAt is stored in the DB as RFC3339 text.
	CreatedAt string
}

type BookmarkArchive struct {
	BookmarkID         int64
	ArchivedURL        string
	ArchivedHTML       string
	ArchiveAttemptedAt string
	ArchivedAt         string
	ArchiveStatus      string
	ArchiveError       string
}
</file>

<file path="internal/core/web/static/app.css">
:root {
  --bg: #0b0f17;
  --panel: rgba(255, 255, 255, 0.06);
  --panel-2: rgba(255, 255, 255, 0.10);
  --text: rgba(255, 255, 255, 0.92);
  --muted: rgba(255, 255, 255, 0.70);
  --border: rgba(255, 255, 255, 0.14);
  --link: #8ab4ff;
  --accent: #7ee787;
  --danger: #ff6b6b;
  --shadow: 0 16px 48px rgba(0,0,0,0.35);
  --radius: 14px;
  --maxw: 980px;
}
@media (prefers-color-scheme: light) {
  :root {
    --bg: #f6f7fb;
    --panel: rgba(0, 0, 0, 0.04);
    --panel-2: rgba(0, 0, 0, 0.06);
    --text: rgba(10, 18, 35, 0.92);
    --muted: rgba(10, 18, 35, 0.68);
    --border: rgba(10, 18, 35, 0.14);
    --link: #1b66ff;
    --accent: #137333;
    --danger: #b42318;
    --shadow: 0 16px 48px rgba(10,18,35,0.12);
  }
}

* { box-sizing: border-box; }
html, body { height: 100%; }
body {
  margin: 0;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  color: var(--text);
  background:
    radial-gradient(1200px 600px at 20% -10%, rgba(138,180,255,0.25), transparent 60%),
    radial-gradient(900px 500px at 100% 0%, rgba(126,231,135,0.18), transparent 55%),
    var(--bg);
  line-height: 1.5;
}

a { color: var(--link); text-decoration: none; }
a:hover { text-decoration: underline; }

.container {
  max-width: var(--maxw);
  margin: 0 auto;
  padding: 32px 18px 56px;
}

header {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  gap: 16px;
  margin-bottom: 22px;
  flex-wrap: wrap;
}

.brand h1 {
  font-size: 28px;
  margin: 0;
  letter-spacing: -0.02em;
}
.brand p {
  margin: 6px 0 0;
  color: var(--muted);
  font-size: 14px;
}

.nav-links {
  display: flex;
  gap: 10px;
  align-items: center;
  flex-wrap: wrap;
}
.nav-link {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  border: 1px solid var(--border);
  border-radius: 999px;
  background: var(--panel);
  font-size: 13px;
  color: var(--muted);
  white-space: nowrap;
}
.nav-link:hover { text-decoration: none; background: var(--panel-2); color: var(--text); }
.nav-link.active { color: var(--text); border-color: rgba(138, 180, 255, 0.35); }

.pill {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  border: 1px solid var(--border);
  border-radius: 999px;
  background: var(--panel);
  font-size: 13px;
  color: var(--muted);
  white-space: nowrap;
}

.card {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  overflow: hidden;
}
.card-header {
  padding: 16px 16px 12px;
  border-bottom: 1px solid var(--border);
  background: linear-gradient(180deg, var(--panel-2), transparent);
}
.card-header h2 {
  margin: 0;
  font-size: 15px;
  letter-spacing: 0.01em;
  text-transform: uppercase;
  color: var(--muted);
}
.card-body { padding: 16px; }

.card-header-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
}

.mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
.muted { color: var(--muted); }

.list { display: grid; gap: 10px; }
.loading { color: var(--muted); text-align: center; padding: 14px; }
.empty {
  padding: 14px;
  border: 1px dashed var(--border);
  border-radius: 12px;
  color: var(--muted);
  text-align: center;
  background: rgba(255,255,255,0.04);
}

button {
  appearance: none;
  border: 1px solid rgba(126,231,135,0.45);
  background: rgba(126,231,135,0.14);
  color: var(--text);
  padding: 10px 12px;
  border-radius: 12px;
  font-weight: 600;
  cursor: pointer;
}
button:hover { background: rgba(126,231,135,0.18); }
button:active { transform: translateY(1px); }
button:disabled { opacity: 0.6; cursor: not-allowed; }

.refresh-btn {
  background: transparent;
  border: 1px solid var(--border);
  padding: 6px 10px;
  font-size: 12px;
  display: inline-flex;
  align-items: center;
  gap: 6px;
}
.refresh-btn:hover { background: var(--panel); }

.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  display: inline-block;
}
.status-ok { background: var(--accent); }
.status-error { background: var(--danger); }
.status-pending { background: var(--muted); opacity: 0.4; }

/* HTMX loading indicator */
.htmx-indicator { display: none; }
.htmx-request .htmx-indicator { display: inline-block; }
.htmx-request.htmx-indicator { display: inline-block; }
.spinner {
  width: 16px;
  height: 16px;
  border: 2px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}
.spinner-sm { width: 14px; height: 14px; border-width: 2px; }
@keyframes spin { to { transform: rotate(360deg); } }

.list-container { position: relative; }
.list-container.htmx-request::after {
  content: '';
  position: absolute;
  inset: 0;
  background: var(--bg);
  opacity: 0.5;
  border-radius: 12px;
}

footer {
  margin-top: 18px;
  color: var(--muted);
  font-size: 12px;
  display: flex;
  justify-content: space-between;
  gap: 12px;
  flex-wrap: wrap;
}
</file>

<file path="internal/core/web/templates/bookmarks.html">
{{/* bookmarks.html: htmx fragment for listing bookmarks */}}
{{ if .bookmarks }}
    {{ range .bookmarks }}
        <div class="bookmark-item">
            <div class="bookmark-header">
                <div class="bookmark-title">
                    <a href="{{ .URL }}" target="_blank" rel="noopener">{{ .Title }}</a>
                </div>
                <div class="bookmark-status">
                    {{ if eq .ArchiveStatus "ok" }}
                        <span class="status-dot status-ok" title="Archived {{ .ArchivedAt }}"></span>
                        <a href="/bookmarks/{{ .ID }}/archive" class="archive-link">View Archive</a>
                    {{ else if eq .ArchiveStatus "error" }}
                        <span class="status-dot status-error" title="Archive failed"></span>
                    {{ else }}
                        <span class="status-dot status-pending" title="Not archived"></span>
                    {{ end }}
                </div>
            </div>
            <div class="bookmark-url">{{ .URL }}</div>
        </div>
    {{ end }}
{{ else }}
    <div class="empty">No bookmarks yet. Add your first one!</div>
{{ end }}
</file>

<file path="internal/core/web/templates/nav.html">
{{/* nav.html: shared navigation partial */}}
{{ define "nav" }}
<nav class="nav-links">
    <a class="nav-link{{ if eq .ActivePage "bookmarks" }} active{{ end }}" href="/">Bookmarks</a>
    <a class="nav-link{{ if eq .ActivePage "archives" }} active{{ end }}" href="/archives">Archives</a>
    <a class="nav-link{{ if eq .ActivePage "bookmarklet" }} active{{ end }}" href="/bookmarklet">Bookmarklet</a>
</nav>
{{ end }}

{{ define "footer" }}
<footer>
    <div>Built with <a href="https://htmx.org" target="_blank" rel="noopener">htmx</a> and Go</div>
</footer>
{{ end }}
</file>

<file path="internal/core/web/handlers_archives.go">
package web

import (
	"fmt"
	"log"
	"net/http"
	"strconv"
	"strings"

	"github.com/seckatie/bookmarkd/internal/core"
	"github.com/seckatie/bookmarkd/internal/core/db"
)

// handleArchive routes archive-related requests
func (ws *Server) handleArchive(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		return
	}

	// Parse bookmark ID from URL: /bookmarks/{id}/archive or /bookmarks/{id}/archive/raw
	path := strings.TrimPrefix(r.URL.Path, "/bookmarks/")
	parts := strings.Split(path, "/")
	if len(parts) < 2 {
		http.Error(w, "Not Found", http.StatusNotFound)
		return
	}

	id, err := strconv.ParseInt(parts[0], 10, 64)
	if err != nil {
		http.Error(w, "Invalid bookmark ID", http.StatusBadRequest)
		return
	}

	// Check if this is a raw request
	if len(parts) >= 3 && parts[2] == "raw" {
		ws.serveArchiveHTML(w, r, id)
		return
	}

	ws.viewArchive(w, r, id)
}

// viewArchive renders the archive viewer page with iframe
func (ws *Server) viewArchive(w http.ResponseWriter, _ *http.Request, id int64) {
	bookmark, err := ws.db.GetBookmark(id)
	if err != nil {
		http.Error(w, "Bookmark not found", http.StatusNotFound)
		return
	}

	archive, err := ws.db.GetBookmarkArchive(id)
	if err != nil || archive.ArchiveStatus != core.ArchiveStatusOK {
		http.Error(w, "Archive not available", http.StatusNotFound)
		return
	}

	view := map[string]any{
		"ID":         bookmark.ID,
		"URL":        bookmark.URL,
		"Title":      bookmark.Title,
		"RawURL":     fmt.Sprintf("/bookmarks/%d/archive/raw", id),
		"ActivePage": "archives",
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	if err := ws.templates.ExecuteTemplate(w, "viewer.html", view); err != nil {
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		log.Printf("Failed to execute viewer template: %v", err)
		return
	}
}

// serveArchiveHTML serves the raw archived HTML content
func (ws *Server) serveArchiveHTML(w http.ResponseWriter, _ *http.Request, id int64) {
	archive, err := ws.db.GetBookmarkArchive(id)
	if err != nil {
		http.Error(w, "Bookmark not found", http.StatusNotFound)
		return
	}

	if archive.ArchiveStatus != core.ArchiveStatusOK || archive.ArchivedHTML == "" {
		http.Error(w, "Archive not available", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	if _, err := w.Write([]byte(archive.ArchivedHTML)); err != nil {
		log.Printf("Failed to write archived HTML: %v", err)
	}
}

// handleArchiveManager serves the archive manager page
func (ws *Server) handleArchiveManager(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		return
	}
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	data := map[string]any{"ActivePage": "archives"}
	if err := ws.templates.ExecuteTemplate(w, "archives.html", data); err != nil {
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		log.Printf("Failed to execute archives template: %v", err)
	}
}

// buildArchiveManagerView builds an archiveManagerView from a bookmark
func (ws *Server) buildArchiveManagerView(b db.Bookmark) archiveManagerView {
	view := archiveManagerView{
		ID:    b.ID,
		URL:   b.URL,
		Title: b.Title,
	}
	archive, err := ws.db.GetBookmarkArchive(b.ID)
	if err == nil {
		view.ArchiveStatus = archive.ArchiveStatus
		view.ArchivedAt = archive.ArchivedAt
		view.ArchiveAttemptedAt = archive.ArchiveAttemptedAt
		view.ArchiveError = archive.ArchiveError
		// IsArchiving is true when there's no archived_at (queued/in-progress)
		// but not when it's an error state
		view.IsArchiving = archive.ArchivedAt == "" && archive.ArchiveStatus != core.ArchiveStatusError
	} else {
		// If we can't get archive info, assume it needs archiving
		view.IsArchiving = true
	}
	return view
}

// handleArchivesList serves the archives list fragment
func (ws *Server) handleArchivesList(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		return
	}

	bookmarks, err := ws.db.ListBookmarks(0)
	if err != nil {
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		log.Printf("Failed to get bookmarks: %v", err)
		return
	}

	var archivesData []archiveManagerView
	for _, b := range bookmarks {
		archivesData = append(archivesData, ws.buildArchiveManagerView(b))
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	if err := ws.templates.ExecuteTemplate(w, "archives_list.html", map[string]any{"archives": archivesData}); err != nil {
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		log.Printf("Failed to execute archives list template: %v", err)
		return
	}
}

// handleArchivesRoutes routes archive management requests
func (ws *Server) handleArchivesRoutes(w http.ResponseWriter, r *http.Request) {
	path := strings.TrimPrefix(r.URL.Path, "/archives/")

	// Handle /archives/list
	if path == "list" {
		ws.handleArchivesList(w, r)
		return
	}

	// Handle /archives/{id}/refetch and /archives/{id}/status
	parts := strings.Split(path, "/")
	if len(parts) >= 2 {
		id, err := strconv.ParseInt(parts[0], 10, 64)
		if err != nil {
			http.Error(w, "Invalid bookmark ID", http.StatusBadRequest)
			return
		}

		switch parts[1] {
		case "refetch":
			if r.Method != http.MethodPost {
				http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
				return
			}
			ws.refetchArchive(w, r, id)
			return
		case "status":
			if r.Method != http.MethodGet {
				http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
				return
			}
			ws.getArchiveItemStatus(w, r, id)
			return
		}
	}

	http.Error(w, "Not Found", http.StatusNotFound)
}

// getArchiveItemStatus returns the current status of a single archive item
func (ws *Server) getArchiveItemStatus(w http.ResponseWriter, _ *http.Request, id int64) {
	bookmark, err := ws.db.GetBookmark(id)
	if err != nil {
		http.Error(w, "Bookmark not found", http.StatusNotFound)
		log.Printf("Failed to get bookmark %d: %v", id, err)
		return
	}

	view := ws.buildArchiveManagerView(bookmark)

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	if err := ws.templates.ExecuteTemplate(w, "archive_item.html", view); err != nil {
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		log.Printf("Failed to execute archive item template: %v", err)
		return
	}
}

// refetchArchive clears an existing archive to queue it for re-archiving
func (ws *Server) refetchArchive(w http.ResponseWriter, r *http.Request, id int64) {
	bookmark, err := ws.db.GetBookmark(id)
	if err != nil {
		http.Error(w, "Bookmark not found", http.StatusNotFound)
		log.Printf("Failed to get bookmark %d: %v", id, err)
		return
	}

	if err := ws.db.ClearBookmarkArchive(id); err != nil {
		http.Error(w, "Failed to clear archive", http.StatusInternalServerError)
		log.Printf("Failed to clear bookmark archive %d: %v", id, err)
		return
	}

	log.Printf("Cleared archive for bookmark %d, queued for re-archiving", id)

	// For HTMX requests, return just the single item in archiving state
	if r.Header.Get("HX-Request") == "true" {
		view := ws.buildArchiveManagerView(bookmark)
		// Force IsArchiving to true since we just cleared it
		view.IsArchiving = true
		view.ArchiveStatus = ""
		view.ArchivedAt = ""
		view.ArchiveError = ""

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := ws.templates.ExecuteTemplate(w, "archive_item.html", view); err != nil {
			http.Error(w, "Internal Server Error", http.StatusInternalServerError)
			log.Printf("Failed to execute archive item template: %v", err)
			return
		}
		return
	}

	http.Redirect(w, r, "/archives", http.StatusSeeOther)
}
</file>

<file path="internal/core/web/handlers_bookmarks.go">
package web

import (
	"log"
	"net/http"
)

func (ws *Server) handleIndex(w http.ResponseWriter, r *http.Request) {
	if !requireMethod(w, r, http.MethodGet) {
		return
	}
	ws.renderTemplate(w, "index.html", map[string]any{"ActivePage": "bookmarks"})
}

func (ws *Server) handleBookmarklet(w http.ResponseWriter, r *http.Request) {
	if !requireMethod(w, r, http.MethodGet) {
		return
	}
	ws.renderTemplate(w, "bookmarklet.html", map[string]any{"ActivePage": "bookmarklet"})
}

func (ws *Server) handleBookmarkletAdd(w http.ResponseWriter, r *http.Request) {
	if !requireMethod(w, r, http.MethodGet) {
		return
	}

	url := r.URL.Query().Get("url")
	title := r.URL.Query().Get("title")

	if url == "" {
		http.Error(w, "Missing url parameter", http.StatusBadRequest)
		return
	}

	if title == "" {
		title = url // Fallback to URL if title is empty
	}

	ws.renderTemplate(w, "bookmarklet_add.html", map[string]string{
		"URL":   url,
		"Title": title,
	})
}

func (ws *Server) handleBookmarks(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodPost:
		ws.createBookmark(w, r)
		return
	case http.MethodGet:
		ws.listBookmarks(w, r)
		return
	default:
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		return
	}
}

func (ws *Server) createBookmark(w http.ResponseWriter, r *http.Request) {
	url := r.FormValue("url")
	title := r.FormValue("title")

	if _, err := ws.db.AddBookmark(url, title); err != nil {
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		log.Printf("Failed to insert bookmark: %v", err)
		return
	}

	// For HTMX requests, return the updated list fragment directly so the page can swap
	// cleanly without a redirect.
	if r.Header.Get("HX-Request") == "true" {
		ws.listBookmarks(w, r)
		return
	}

	http.Redirect(w, r, "/", http.StatusSeeOther)
}

func (ws *Server) listBookmarks(w http.ResponseWriter, _ *http.Request) {
	bookmarks, err := ws.db.ListBookmarks(0)
	if err != nil {
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		log.Printf("Failed to get bookmarks: %v", err)
		return
	}

	var bookmarksData []bookmarkView
	for _, b := range bookmarks {
		view := bookmarkView{
			ID:    b.ID,
			URL:   b.URL,
			Title: b.Title,
		}
		// Fetch archive status for this bookmark
		archive, err := ws.db.GetBookmarkArchive(b.ID)
		if err == nil {
			view.ArchiveStatus = archive.ArchiveStatus
			view.ArchivedAt = archive.ArchivedAt
		}
		bookmarksData = append(bookmarksData, view)
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	if err := ws.templates.ExecuteTemplate(w, "bookmarks.html", map[string]any{"bookmarks": bookmarksData}); err != nil {
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		log.Printf("Failed to execute template: %v", err)
		return
	}
}
</file>

<file path="internal/core/web/handlers_test.go">
package web

import (
	"net/http"
	"net/http/httptest"
	"net/url"
	"strconv"
	"strings"
	"testing"
	"time"
)

// TestHandleIndex tests the index page handler.
func TestHandleIndex(t *testing.T) {
	server := newTestServer(t)
	t.Cleanup(func() {
		if err := server.db.Close(); err != nil {
			t.Errorf("failed to close db: %v", err)
		}
	})

	t.Run("GET returns index page", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/", nil)
		w := httptest.NewRecorder()

		server.handleIndex(w, req)

		if w.Code != http.StatusOK {
			t.Errorf("expected status %d, got %d", http.StatusOK, w.Code)
		}
		if ct := w.Header().Get("Content-Type"); ct != "text/html; charset=utf-8" {
			t.Errorf("expected Content-Type 'text/html; charset=utf-8', got %q", ct)
		}
		if !strings.Contains(w.Body.String(), "bookmarkd") {
			t.Error("expected response to contain 'bookmarkd'")
		}
	})

	t.Run("POST returns method not allowed", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodPost, "/", nil)
		w := httptest.NewRecorder()

		server.handleIndex(w, req)

		if w.Code != http.StatusMethodNotAllowed {
			t.Errorf("expected status %d, got %d", http.StatusMethodNotAllowed, w.Code)
		}
	})
}

// TestHandleBookmarklet tests the bookmarklet page handler.
func TestHandleBookmarklet(t *testing.T) {
	server := newTestServer(t)
	t.Cleanup(func() {
		if err := server.db.Close(); err != nil {
			t.Errorf("failed to close db: %v", err)
		}
	})

	t.Run("GET returns bookmarklet page", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/bookmarklet", nil)
		w := httptest.NewRecorder()

		server.handleBookmarklet(w, req)

		if w.Code != http.StatusOK {
			t.Errorf("expected status %d, got %d", http.StatusOK, w.Code)
		}
		if ct := w.Header().Get("Content-Type"); ct != "text/html; charset=utf-8" {
			t.Errorf("expected Content-Type 'text/html; charset=utf-8', got %q", ct)
		}
	})

	t.Run("POST returns method not allowed", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodPost, "/bookmarklet", nil)
		w := httptest.NewRecorder()

		server.handleBookmarklet(w, req)

		if w.Code != http.StatusMethodNotAllowed {
			t.Errorf("expected status %d, got %d", http.StatusMethodNotAllowed, w.Code)
		}
	})
}

// TestHandleBookmarkletAdd tests the bookmarklet add handler.
func TestHandleBookmarkletAdd(t *testing.T) {
	server := newTestServer(t)
	t.Cleanup(func() {
		if err := server.db.Close(); err != nil {
			t.Errorf("failed to close db: %v", err)
		}
	})

	t.Run("GET with url and title", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/bookmarklet/add?url=https://example.com&title=Example", nil)
		w := httptest.NewRecorder()

		server.handleBookmarkletAdd(w, req)

		if w.Code != http.StatusOK {
			t.Errorf("expected status %d, got %d", http.StatusOK, w.Code)
		}
		body := w.Body.String()
		if !strings.Contains(body, "https://example.com") {
			t.Error("expected response to contain URL")
		}
		if !strings.Contains(body, "Example") {
			t.Error("expected response to contain title")
		}
	})

	t.Run("GET with url only uses url as title", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/bookmarklet/add?url=https://example.com", nil)
		w := httptest.NewRecorder()

		server.handleBookmarkletAdd(w, req)

		if w.Code != http.StatusOK {
			t.Errorf("expected status %d, got %d", http.StatusOK, w.Code)
		}
	})

	t.Run("GET without url returns bad request", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/bookmarklet/add", nil)
		w := httptest.NewRecorder()

		server.handleBookmarkletAdd(w, req)

		if w.Code != http.StatusBadRequest {
			t.Errorf("expected status %d, got %d", http.StatusBadRequest, w.Code)
		}
	})

	t.Run("POST returns method not allowed", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodPost, "/bookmarklet/add?url=https://example.com", nil)
		w := httptest.NewRecorder()

		server.handleBookmarkletAdd(w, req)

		if w.Code != http.StatusMethodNotAllowed {
			t.Errorf("expected status %d, got %d", http.StatusMethodNotAllowed, w.Code)
		}
	})
}

// TestHandleBookmarks tests the bookmarks list/create handler.
func TestHandleBookmarks(t *testing.T) {
	server := newTestServer(t)
	t.Cleanup(func() {
		if err := server.db.Close(); err != nil {
			t.Errorf("failed to close db: %v", err)
		}
	})

	t.Run("GET returns bookmarks list", func(t *testing.T) {
		// Add a bookmark first
		if _, err := server.db.AddBookmark("https://example.com", "Example Site"); err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}

		req := httptest.NewRequest(http.MethodGet, "/bookmarks", nil)
		w := httptest.NewRecorder()

		server.handleBookmarks(w, req)

		if w.Code != http.StatusOK {
			t.Errorf("expected status %d, got %d", http.StatusOK, w.Code)
		}
		body := w.Body.String()
		if !strings.Contains(body, "example.com") {
			t.Error("expected response to contain bookmark URL")
		}
	})

	t.Run("POST creates bookmark and redirects", func(t *testing.T) {
		form := url.Values{}
		form.Add("url", "https://newsite.com")
		form.Add("title", "New Site")

		req := httptest.NewRequest(http.MethodPost, "/bookmarks", strings.NewReader(form.Encode()))
		req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
		w := httptest.NewRecorder()

		server.handleBookmarks(w, req)

		if w.Code != http.StatusSeeOther {
			t.Errorf("expected status %d, got %d", http.StatusSeeOther, w.Code)
		}
		if loc := w.Header().Get("Location"); loc != "/" {
			t.Errorf("expected redirect to '/', got %q", loc)
		}
	})

	t.Run("POST with HX-Request returns list fragment", func(t *testing.T) {
		form := url.Values{}
		form.Add("url", "https://htmxsite.com")
		form.Add("title", "HTMX Site")

		req := httptest.NewRequest(http.MethodPost, "/bookmarks", strings.NewReader(form.Encode()))
		req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
		req.Header.Set("HX-Request", "true")
		w := httptest.NewRecorder()

		server.handleBookmarks(w, req)

		if w.Code != http.StatusOK {
			t.Errorf("expected status %d, got %d", http.StatusOK, w.Code)
		}
		// Should return HTML fragment, not redirect
		if w.Header().Get("Location") != "" {
			t.Error("expected no redirect for HTMX request")
		}
	})

	t.Run("DELETE returns method not allowed", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodDelete, "/bookmarks", nil)
		w := httptest.NewRecorder()

		server.handleBookmarks(w, req)

		if w.Code != http.StatusMethodNotAllowed {
			t.Errorf("expected status %d, got %d", http.StatusMethodNotAllowed, w.Code)
		}
	})
}

// TestHandleArchive tests the archive viewer handler.
func TestHandleArchive(t *testing.T) {
	server := newTestServer(t)
	t.Cleanup(func() {
		if err := server.db.Close(); err != nil {
			t.Errorf("failed to close db: %v", err)
		}
	})

	t.Run("GET with invalid path returns not found", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/bookmarks/", nil)
		w := httptest.NewRecorder()

		server.handleArchive(w, req)

		if w.Code != http.StatusNotFound {
			t.Errorf("expected status %d, got %d", http.StatusNotFound, w.Code)
		}
	})

	t.Run("GET with invalid ID returns bad request", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/bookmarks/abc/archive", nil)
		w := httptest.NewRecorder()

		server.handleArchive(w, req)

		if w.Code != http.StatusBadRequest {
			t.Errorf("expected status %d, got %d", http.StatusBadRequest, w.Code)
		}
	})

	t.Run("GET archive for non-existent bookmark returns not found", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/bookmarks/99999/archive", nil)
		w := httptest.NewRecorder()

		server.handleArchive(w, req)

		if w.Code != http.StatusNotFound {
			t.Errorf("expected status %d, got %d", http.StatusNotFound, w.Code)
		}
	})

	t.Run("GET archive for bookmark without archive returns not found", func(t *testing.T) {
		id, err := server.db.AddBookmark("https://example.com", "Example")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}

		req := httptest.NewRequest(http.MethodGet, "/bookmarks/"+itoa(id)+"/archive", nil)
		w := httptest.NewRecorder()

		server.handleArchive(w, req)

		if w.Code != http.StatusNotFound {
			t.Errorf("expected status %d, got %d", http.StatusNotFound, w.Code)
		}
	})

	t.Run("GET archive for archived bookmark returns viewer", func(t *testing.T) {
		id, err := server.db.AddBookmark("https://archived.com", "Archived Site")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}
		now := time.Now()
		if err := server.db.SaveArchiveResult(id, now, &now, "ok", "", "https://archived.com", "<html><body>Archived</body></html>"); err != nil {
			t.Fatalf("failed to save archive result: %v", err)
		}

		req := httptest.NewRequest(http.MethodGet, "/bookmarks/"+itoa(id)+"/archive", nil)
		w := httptest.NewRecorder()

		server.handleArchive(w, req)

		if w.Code != http.StatusOK {
			t.Errorf("expected status %d, got %d", http.StatusOK, w.Code)
		}
		body := w.Body.String()
		if !strings.Contains(body, "Archived Site") {
			t.Error("expected response to contain bookmark title")
		}
	})

	t.Run("GET raw archive returns HTML content", func(t *testing.T) {
		id, err := server.db.AddBookmark("https://raw.com", "Raw Site")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}
		now := time.Now()
		htmlContent := "<html><body>Raw HTML Content</body></html>"
		if err := server.db.SaveArchiveResult(id, now, &now, "ok", "", "https://raw.com", htmlContent); err != nil {
			t.Fatalf("failed to save archive result: %v", err)
		}

		req := httptest.NewRequest(http.MethodGet, "/bookmarks/"+itoa(id)+"/archive/raw", nil)
		w := httptest.NewRecorder()

		server.handleArchive(w, req)

		if w.Code != http.StatusOK {
			t.Errorf("expected status %d, got %d", http.StatusOK, w.Code)
		}
		if w.Body.String() != htmlContent {
			t.Errorf("expected raw HTML content, got %q", w.Body.String())
		}
	})

	t.Run("POST returns method not allowed", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodPost, "/bookmarks/1/archive", nil)
		w := httptest.NewRecorder()

		server.handleArchive(w, req)

		if w.Code != http.StatusMethodNotAllowed {
			t.Errorf("expected status %d, got %d", http.StatusMethodNotAllowed, w.Code)
		}
	})
}

// TestHandleArchiveManager tests the archive manager page handler.
func TestHandleArchiveManager(t *testing.T) {
	server := newTestServer(t)
	t.Cleanup(func() {
		if err := server.db.Close(); err != nil {
			t.Errorf("failed to close db: %v", err)
		}
	})

	t.Run("GET returns archive manager page", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/archives", nil)
		w := httptest.NewRecorder()

		server.handleArchiveManager(w, req)

		if w.Code != http.StatusOK {
			t.Errorf("expected status %d, got %d", http.StatusOK, w.Code)
		}
		if ct := w.Header().Get("Content-Type"); ct != "text/html; charset=utf-8" {
			t.Errorf("expected Content-Type 'text/html; charset=utf-8', got %q", ct)
		}
	})

	t.Run("POST returns method not allowed", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodPost, "/archives", nil)
		w := httptest.NewRecorder()

		server.handleArchiveManager(w, req)

		if w.Code != http.StatusMethodNotAllowed {
			t.Errorf("expected status %d, got %d", http.StatusMethodNotAllowed, w.Code)
		}
	})
}

// TestHandleArchivesList tests the archives list fragment handler.
func TestHandleArchivesList(t *testing.T) {
	server := newTestServer(t)
	t.Cleanup(func() {
		if err := server.db.Close(); err != nil {
			t.Errorf("failed to close db: %v", err)
		}
	})

	t.Run("GET returns archives list", func(t *testing.T) {
		if _, err := server.db.AddBookmark("https://example.com", "Example"); err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}

		req := httptest.NewRequest(http.MethodGet, "/archives/list", nil)
		w := httptest.NewRecorder()

		server.handleArchivesList(w, req)

		if w.Code != http.StatusOK {
			t.Errorf("expected status %d, got %d", http.StatusOK, w.Code)
		}
		body := w.Body.String()
		if !strings.Contains(body, "example.com") {
			t.Error("expected response to contain bookmark URL")
		}
	})

	t.Run("POST returns method not allowed", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodPost, "/archives/list", nil)
		w := httptest.NewRecorder()

		server.handleArchivesList(w, req)

		if w.Code != http.StatusMethodNotAllowed {
			t.Errorf("expected status %d, got %d", http.StatusMethodNotAllowed, w.Code)
		}
	})
}

// TestHandleArchivesRoutes tests the archives routing handler.
func TestHandleArchivesRoutes(t *testing.T) {
	server := newTestServer(t)
	t.Cleanup(func() {
		if err := server.db.Close(); err != nil {
			t.Errorf("failed to close db: %v", err)
		}
	})

	t.Run("routes to list handler", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/archives/list", nil)
		w := httptest.NewRecorder()

		server.handleArchivesRoutes(w, req)

		if w.Code != http.StatusOK {
			t.Errorf("expected status %d, got %d", http.StatusOK, w.Code)
		}
	})

	t.Run("routes to status handler", func(t *testing.T) {
		id, err := server.db.AddBookmark("https://example.com", "Example")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}

		req := httptest.NewRequest(http.MethodGet, "/archives/"+itoa(id)+"/status", nil)
		w := httptest.NewRecorder()

		server.handleArchivesRoutes(w, req)

		if w.Code != http.StatusOK {
			t.Errorf("expected status %d, got %d", http.StatusOK, w.Code)
		}
	})

	t.Run("status for non-existent bookmark returns not found", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/archives/99999/status", nil)
		w := httptest.NewRecorder()

		server.handleArchivesRoutes(w, req)

		if w.Code != http.StatusNotFound {
			t.Errorf("expected status %d, got %d", http.StatusNotFound, w.Code)
		}
	})

	t.Run("refetch requires POST", func(t *testing.T) {
		id, err := server.db.AddBookmark("https://example.com", "Example")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}

		req := httptest.NewRequest(http.MethodGet, "/archives/"+itoa(id)+"/refetch", nil)
		w := httptest.NewRecorder()

		server.handleArchivesRoutes(w, req)

		if w.Code != http.StatusMethodNotAllowed {
			t.Errorf("expected status %d, got %d", http.StatusMethodNotAllowed, w.Code)
		}
	})

	t.Run("invalid path returns not found", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/archives/invalid/path", nil)
		w := httptest.NewRecorder()

		server.handleArchivesRoutes(w, req)

		if w.Code != http.StatusBadRequest {
			t.Errorf("expected status %d, got %d", http.StatusBadRequest, w.Code)
		}
	})

	t.Run("unknown route returns not found", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/archives/1/unknown", nil)
		w := httptest.NewRecorder()

		server.handleArchivesRoutes(w, req)

		if w.Code != http.StatusNotFound {
			t.Errorf("expected status %d, got %d", http.StatusNotFound, w.Code)
		}
	})
}

// TestRefetchArchive tests the refetch archive handler.
func TestRefetchArchive(t *testing.T) {
	server := newTestServer(t)
	t.Cleanup(func() {
		if err := server.db.Close(); err != nil {
			t.Errorf("failed to close db: %v", err)
		}
	})

	t.Run("POST clears archive and redirects", func(t *testing.T) {
		id, err := server.db.AddBookmark("https://example.com", "Example")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}
		now := time.Now()
		if err := server.db.SaveArchiveResult(id, now, &now, "ok", "", "https://example.com", "<html></html>"); err != nil {
			t.Fatalf("failed to save archive result: %v", err)
		}

		req := httptest.NewRequest(http.MethodPost, "/archives/"+itoa(id)+"/refetch", nil)
		w := httptest.NewRecorder()

		server.refetchArchive(w, req, id)

		if w.Code != http.StatusSeeOther {
			t.Errorf("expected status %d, got %d", http.StatusSeeOther, w.Code)
		}

		// Verify archive was cleared
		archive, _ := server.db.GetBookmarkArchive(id)
		if archive.ArchiveStatus != "" {
			t.Error("expected archive to be cleared")
		}
	})

	t.Run("POST with HX-Request returns item fragment", func(t *testing.T) {
		id, err := server.db.AddBookmark("https://htmx.com", "HTMX")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}
		now := time.Now()
		if err := server.db.SaveArchiveResult(id, now, &now, "ok", "", "https://htmx.com", "<html></html>"); err != nil {
			t.Fatalf("failed to save archive result: %v", err)
		}

		req := httptest.NewRequest(http.MethodPost, "/archives/"+itoa(id)+"/refetch", nil)
		req.Header.Set("HX-Request", "true")
		w := httptest.NewRecorder()

		server.refetchArchive(w, req, id)

		if w.Code != http.StatusOK {
			t.Errorf("expected status %d, got %d", http.StatusOK, w.Code)
		}
		// Should return HTML fragment, not redirect
		if w.Header().Get("Location") != "" {
			t.Error("expected no redirect for HTMX request")
		}
	})

	t.Run("POST for non-existent bookmark returns not found", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodPost, "/archives/99999/refetch", nil)
		w := httptest.NewRecorder()

		server.refetchArchive(w, req, 99999)

		if w.Code != http.StatusNotFound {
			t.Errorf("expected status %d, got %d", http.StatusNotFound, w.Code)
		}
	})
}

// TestBuildArchiveManagerView tests the view builder function.
func TestBuildArchiveManagerView(t *testing.T) {
	server := newTestServer(t)
	t.Cleanup(func() {
		if err := server.db.Close(); err != nil {
			t.Errorf("failed to close db: %v", err)
		}
	})

	t.Run("builds view for unarchived bookmark", func(t *testing.T) {
		id, err := server.db.AddBookmark("https://example.com", "Example")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}
		bookmark, err := server.db.GetBookmark(id)
		if err != nil {
			t.Fatalf("failed to get bookmark: %v", err)
		}

		view := server.buildArchiveManagerView(bookmark)

		if view.ID != id {
			t.Errorf("expected ID %d, got %d", id, view.ID)
		}
		if view.URL != "https://example.com" {
			t.Errorf("expected URL 'https://example.com', got %q", view.URL)
		}
		if view.Title != "Example" {
			t.Errorf("expected Title 'Example', got %q", view.Title)
		}
		if !view.IsArchiving {
			t.Error("expected IsArchiving to be true for unarchived bookmark")
		}
	})

	t.Run("builds view for archived bookmark", func(t *testing.T) {
		id, err := server.db.AddBookmark("https://archived.com", "Archived")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}
		now := time.Now()
		if err := server.db.SaveArchiveResult(id, now, &now, "ok", "", "https://archived.com", "<html></html>"); err != nil {
			t.Fatalf("failed to save archive result: %v", err)
		}
		bookmark, err := server.db.GetBookmark(id)
		if err != nil {
			t.Fatalf("failed to get bookmark: %v", err)
		}

		view := server.buildArchiveManagerView(bookmark)

		if view.ArchiveStatus != "ok" {
			t.Errorf("expected ArchiveStatus 'ok', got %q", view.ArchiveStatus)
		}
		if view.IsArchiving {
			t.Error("expected IsArchiving to be false for archived bookmark")
		}
	})

	t.Run("builds view for failed archive", func(t *testing.T) {
		id, err := server.db.AddBookmark("https://failed.com", "Failed")
		if err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}
		now := time.Now()
		if err := server.db.SaveArchiveResult(id, now, nil, "error", "connection timeout", "", ""); err != nil {
			t.Fatalf("failed to save archive result: %v", err)
		}
		bookmark, err := server.db.GetBookmark(id)
		if err != nil {
			t.Fatalf("failed to get bookmark: %v", err)
		}

		view := server.buildArchiveManagerView(bookmark)

		if view.ArchiveStatus != "error" {
			t.Errorf("expected ArchiveStatus 'error', got %q", view.ArchiveStatus)
		}
		if view.ArchiveError != "connection timeout" {
			t.Errorf("expected ArchiveError 'connection timeout', got %q", view.ArchiveError)
		}
		if view.IsArchiving {
			t.Error("expected IsArchiving to be false for failed archive")
		}
	})
}

// itoa converts an int64 to string for URL building.
func itoa(n int64) string {
	return strconv.FormatInt(n, 10)
}
</file>

<file path="internal/core/web/views.go">
package web

type bookmarkView struct {
	ID            int64
	URL           string
	Title         string
	ArchiveStatus string // "", "ok", "error"
	ArchivedAt    string
}

type archiveManagerView struct {
	ID                 int64
	URL                string
	Title              string
	ArchiveStatus      string // "", "ok", "error"
	ArchivedAt         string
	ArchiveAttemptedAt string
	ArchiveError       string
	IsArchiving        bool // true when archive is queued or in progress
}
</file>

<file path="internal/core/archive_test.go">
package core

import (
	"context"
	"testing"
	"time"

	"github.com/seckatie/bookmarkd/internal/core/db"
)

func TestArchiveOptions(t *testing.T) {
	t.Run("default timeout is applied", func(t *testing.T) {
		opts := ArchiveOptions{}
		if opts.Timeout != 0 {
			t.Errorf("initial Timeout should be 0, got %v", opts.Timeout)
		}
		// The default is applied inside ArchiveBookmark, not in the struct
	})

	t.Run("headless defaults to false", func(t *testing.T) {
		opts := ArchiveOptions{}
		if opts.Headless {
			t.Error("Headless should default to false")
		}
	})

	t.Run("custom chrome path", func(t *testing.T) {
		opts := ArchiveOptions{ChromePath: "/custom/chrome"}
		if opts.ChromePath != "/custom/chrome" {
			t.Errorf("ChromePath = %q, want /custom/chrome", opts.ChromePath)
		}
	})

	t.Run("wait selector", func(t *testing.T) {
		opts := ArchiveOptions{WaitSelector: ".main-content"}
		if opts.WaitSelector != ".main-content" {
			t.Errorf("WaitSelector = %q, want .main-content", opts.WaitSelector)
		}
	})
}

func TestArchiveResult(t *testing.T) {
	t.Run("empty result", func(t *testing.T) {
		result := ArchiveResult{}
		if result.FinalURL != "" {
			t.Error("FinalURL should be empty")
		}
		if result.Title != "" {
			t.Error("Title should be empty")
		}
		if result.HTML != "" {
			t.Error("HTML should be empty")
		}
	})

	t.Run("populated result", func(t *testing.T) {
		result := ArchiveResult{
			FinalURL: "https://example.com/final",
			Title:    "Example Page",
			HTML:     "<html><body>Test</body></html>",
		}
		if result.FinalURL != "https://example.com/final" {
			t.Errorf("FinalURL = %q, want https://example.com/final", result.FinalURL)
		}
		if result.Title != "Example Page" {
			t.Errorf("Title = %q, want Example Page", result.Title)
		}
		if result.HTML != "<html><body>Test</body></html>" {
			t.Errorf("HTML = %q, want <html><body>Test</body></html>", result.HTML)
		}
	})
}

func TestArchiveRunOptions(t *testing.T) {
	t.Run("single bookmark mode", func(t *testing.T) {
		opts := ArchiveRunOptions{ID: 123}
		if opts.ID != 123 {
			t.Errorf("ID = %d, want 123", opts.ID)
		}
	})

	t.Run("batch mode with limit", func(t *testing.T) {
		opts := ArchiveRunOptions{Limit: 10}
		if opts.Limit != 10 {
			t.Errorf("Limit = %d, want 10", opts.Limit)
		}
	})

	t.Run("nested archive options", func(t *testing.T) {
		opts := ArchiveRunOptions{
			Options: ArchiveOptions{
				Headless: true,
				Timeout:  30 * time.Second,
			},
		}
		if !opts.Options.Headless {
			t.Error("Options.Headless should be true")
		}
		if opts.Options.Timeout != 30*time.Second {
			t.Errorf("Options.Timeout = %v, want 30s", opts.Options.Timeout)
		}
	})
}

func TestArchiveRunResult(t *testing.T) {
	t.Run("all succeeded", func(t *testing.T) {
		result := ArchiveRunResult{Attempted: 5, Succeeded: 5, Failed: 0}
		if result.Attempted != 5 {
			t.Errorf("Attempted = %d, want 5", result.Attempted)
		}
		if result.Succeeded != 5 {
			t.Errorf("Succeeded = %d, want 5", result.Succeeded)
		}
		if result.Failed != 0 {
			t.Errorf("Failed = %d, want 0", result.Failed)
		}
	})

	t.Run("partial failure", func(t *testing.T) {
		result := ArchiveRunResult{Attempted: 5, Succeeded: 3, Failed: 2}
		if result.Attempted != 5 {
			t.Errorf("Attempted = %d, want 5", result.Attempted)
		}
		if result.Succeeded != 3 {
			t.Errorf("Succeeded = %d, want 3", result.Succeeded)
		}
		if result.Failed != 2 {
			t.Errorf("Failed = %d, want 2", result.Failed)
		}
	})
}

func TestRunArchive_SingleBookmark(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test in short mode")
	}

	// Create test database
	database, err := db.NewSQLiteDB(":memory:")
	if err != nil {
		t.Fatalf("failed to create test database: %v", err)
	}
	t.Cleanup(func() {
		if err := database.Close(); err != nil {
			t.Errorf("failed to close database: %v", err)
		}
	})

	if err := database.Migrate(); err != nil {
		t.Fatalf("failed to migrate database: %v", err)
	}

	// Add a bookmark
	id, err := database.AddBookmark("https://example.com", "Example")
	if err != nil {
		t.Fatalf("failed to add bookmark: %v", err)
	}

	// Run archive for non-existent bookmark should fail
	_, err = RunArchive(context.Background(), database, ArchiveRunOptions{
		ID: 99999,
		Options: ArchiveOptions{
			Headless: true,
			Timeout:  10 * time.Second,
		},
	})
	if err == nil {
		t.Error("expected error for non-existent bookmark")
	}

	// Note: Actually archiving requires Chrome, so we skip the success case in unit tests
	_ = id
}

func TestRunArchive_BatchMode_NoBookmarks(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test in short mode")
	}

	// Create test database
	database, err := db.NewSQLiteDB(":memory:")
	if err != nil {
		t.Fatalf("failed to create test database: %v", err)
	}
	t.Cleanup(func() {
		if err := database.Close(); err != nil {
			t.Errorf("failed to close database: %v", err)
		}
	})

	if err := database.Migrate(); err != nil {
		t.Fatalf("failed to migrate database: %v", err)
	}

	// Run archive with no bookmarks
	result, err := RunArchive(context.Background(), database, ArchiveRunOptions{
		Options: ArchiveOptions{
			Headless: true,
			Timeout:  10 * time.Second,
		},
	})
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if result.Attempted != 0 {
		t.Errorf("Attempted = %d, want 0", result.Attempted)
	}
}

func TestArchiveConstants(t *testing.T) {
	t.Run("DefaultArchiveTimeout", func(t *testing.T) {
		if DefaultArchiveTimeout != 35*time.Second {
			t.Errorf("DefaultArchiveTimeout = %v, want 35s", DefaultArchiveTimeout)
		}
	})

	t.Run("DefaultNetworkIdleDelay", func(t *testing.T) {
		if DefaultNetworkIdleDelay != 500*time.Millisecond {
			t.Errorf("DefaultNetworkIdleDelay = %v, want 500ms", DefaultNetworkIdleDelay)
		}
	})

	t.Run("ArchiveStatusOK", func(t *testing.T) {
		if ArchiveStatusOK != "ok" {
			t.Errorf("ArchiveStatusOK = %q, want ok", ArchiveStatusOK)
		}
	})

	t.Run("ArchiveStatusError", func(t *testing.T) {
		if ArchiveStatusError != "error" {
			t.Errorf("ArchiveStatusError = %q, want error", ArchiveStatusError)
		}
	})
}

// TestArchiveBookmark_RequiresBrowser tests the browser-based archiving.
// It's skipped by default since it requires Chrome to be available.
func TestArchiveBookmark_RequiresBrowser(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping browser test in short mode")
	}

	// This test requires Chrome to be installed
	// Run with: go test -v -run TestArchiveBookmark_RequiresBrowser ./internal/core/...

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	result, err := ArchiveBookmark(ctx, "https://example.com", ArchiveOptions{
		Headless: true,
		Timeout:  20 * time.Second,
	})
	if err != nil {
		t.Skipf("Chrome not available or failed: %v", err)
	}

	if result.FinalURL == "" {
		t.Error("FinalURL should not be empty")
	}
	if result.HTML == "" {
		t.Error("HTML should not be empty")
	}
	if result.Title == "" {
		t.Log("Warning: Title is empty (some pages have no title)")
	}
}
</file>

<file path="internal/core/constants.go">
package core

import "time"

// Archive status values used in database and handlers
const (
	ArchiveStatusOK    = "ok"
	ArchiveStatusError = "error"
)

// Timeout defaults for archiving operations
const (
	DefaultArchiveTimeout   = 35 * time.Second
	DefaultResourceTimeout  = 10 * time.Second
	DefaultNetworkIdleDelay = 500 * time.Millisecond
)

// Resource limits
const (
	MaxResourceSize = 5 * 1024 * 1024 // 5MB
)

// HTTP client configuration
const (
	UserAgent = "Mozilla/5.0 (compatible; bookmarkd/1.0)"
)
</file>

<file path="internal/core/inline_test.go">
package core

import (
	"context"
	"net/http"
	"net/http/httptest"
	"net/url"
	"os"
	"strings"
	"testing"
	"time"
)

// TestMain sets up the test environment.
// We enable internal URLs for testing since httptest.NewServer uses localhost.
func TestMain(m *testing.M) {
	AllowInternalURLsForTesting = true
	code := m.Run()
	AllowInternalURLsForTesting = false
	os.Exit(code)
}

func TestResolveURL(t *testing.T) {
	base, _ := url.Parse("https://example.com/page/")

	tests := []struct {
		name     string
		ref      string
		expected string
	}{
		{"empty", "", ""},
		{"absolute URL", "https://other.com/file.css", "https://other.com/file.css"},
		{"relative path", "style.css", "https://example.com/page/style.css"},
		{"root relative", "/style.css", "https://example.com/style.css"},
		{"parent path", "../style.css", "https://example.com/style.css"},
		{"protocol relative", "//cdn.example.com/file.js", "https://cdn.example.com/file.js"},
		{"data URI", "data:text/css,body{}", ""},
		{"javascript", "javascript:void(0)", ""},
		{"query string", "style.css?v=1.0", "https://example.com/page/style.css?v=1.0"},
		{"fragment", "style.css#section", "https://example.com/page/style.css#section"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := resolveURL(base, tt.ref)
			if result != tt.expected {
				t.Errorf("resolveURL(%q) = %q, want %q", tt.ref, result, tt.expected)
			}
		})
	}
}

func TestFetchURL(t *testing.T) {
	tests := []struct {
		name          string
		handler       http.HandlerFunc
		maxSize       int64
		wantErr       bool
		wantData      string
		wantType      string
		errContains   string
	}{
		{
			name: "successful fetch",
			handler: func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Content-Type", "text/plain")
				if _, err := w.Write([]byte("hello world")); err != nil {
					http.Error(w, err.Error(), http.StatusInternalServerError)
				}
			},
			wantData: "hello world",
			wantType: "text/plain",
		},
		{
			name: "404 error",
			handler: func(w http.ResponseWriter, r *http.Request) {
				http.Error(w, "not found", http.StatusNotFound)
			},
			wantErr:     true,
			errContains: "HTTP 404",
		},
		{
			name: "500 error",
			handler: func(w http.ResponseWriter, r *http.Request) {
				http.Error(w, "server error", http.StatusInternalServerError)
			},
			wantErr:     true,
			errContains: "HTTP 500",
		},
		{
			name: "content type detection",
			handler: func(w http.ResponseWriter, r *http.Request) {
				// PNG magic bytes
				if _, err := w.Write([]byte{0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A}); err != nil {
					http.Error(w, err.Error(), http.StatusInternalServerError)
				}
			},
			wantType: "image/png",
		},
		{
			name: "size limit",
			handler: func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Content-Type", "text/plain")
				if _, err := w.Write([]byte("12345678901234567890")); err != nil { // 20 bytes
					http.Error(w, err.Error(), http.StatusInternalServerError)
				}
			},
			maxSize:  10,
			wantData: "1234567890", // truncated to 10 bytes
		},
		{
			name: "user agent header",
			handler: func(w http.ResponseWriter, r *http.Request) {
				ua := r.Header.Get("User-Agent")
				if !strings.Contains(ua, "bookmarkd") {
					http.Error(w, "wrong user agent", http.StatusBadRequest)
					return
				}
				if _, err := w.Write([]byte("ok")); err != nil {
					http.Error(w, err.Error(), http.StatusInternalServerError)
				}
			},
			wantData: "ok",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ts := httptest.NewServer(tt.handler)
			defer ts.Close()

			client := &http.Client{Timeout: 5 * time.Second}
			result, err := fetchURL(context.Background(), client, ts.URL, tt.maxSize)

			if tt.wantErr {
				if err == nil {
					t.Fatal("expected error, got nil")
				}
				if tt.errContains != "" && !strings.Contains(err.Error(), tt.errContains) {
					t.Errorf("error %q should contain %q", err.Error(), tt.errContains)
				}
				return
			}

			if err != nil {
				t.Fatalf("unexpected error: %v", err)
			}

			if tt.wantData != "" && string(result.data) != tt.wantData {
				t.Errorf("data = %q, want %q", string(result.data), tt.wantData)
			}

			if tt.wantType != "" && !strings.HasPrefix(result.contentType, tt.wantType) {
				t.Errorf("contentType = %q, want prefix %q", result.contentType, tt.wantType)
			}
		})
	}
}

func TestFetchResource(t *testing.T) {
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "text/css")
		if _, err := w.Write([]byte("body { color: red; }")); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		}
	}))
	defer ts.Close()

	client := &http.Client{Timeout: 5 * time.Second}
	result, err := fetchResource(context.Background(), client, ts.URL, 0)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	expected := "body { color: red; }"
	if result != expected {
		t.Errorf("result = %q, want %q", result, expected)
	}
}

func TestFetchAsDataURI(t *testing.T) {
	tests := []struct {
		name        string
		contentType string
		data        []byte
		wantPrefix  string
	}{
		{
			name:        "plain text",
			contentType: "text/plain",
			data:        []byte("hello"),
			wantPrefix:  "data:text/plain;base64,",
		},
		{
			name:        "CSS",
			contentType: "text/css; charset=utf-8",
			data:        []byte("body{}"),
			wantPrefix:  "data:text/css;base64,", // charset stripped
		},
		{
			name:        "PNG image",
			contentType: "image/png",
			data:        []byte{0x89, 0x50, 0x4E, 0x47},
			wantPrefix:  "data:image/png;base64,",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Content-Type", tt.contentType)
				if _, err := w.Write(tt.data); err != nil {
					http.Error(w, err.Error(), http.StatusInternalServerError)
				}
			}))
			defer ts.Close()

			client := &http.Client{Timeout: 5 * time.Second}
			result, err := fetchAsDataURI(context.Background(), client, ts.URL, 0)
			if err != nil {
				t.Fatalf("unexpected error: %v", err)
			}

			if !strings.HasPrefix(result, tt.wantPrefix) {
				t.Errorf("result should start with %q, got %q", tt.wantPrefix, result)
			}
		})
	}
}

func TestInlineResources(t *testing.T) {
	// Set up test server that serves different resources
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case "/style.css":
			w.Header().Set("Content-Type", "text/css")
			w.Write([]byte("body { color: red; }"))
		case "/script.js":
			w.Header().Set("Content-Type", "application/javascript")
			w.Write([]byte("console.log('hello');"))
		case "/image.png":
			w.Header().Set("Content-Type", "image/png")
			// Minimal PNG
			w.Write([]byte{0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A})
		case "/css-with-url.css":
			w.Header().Set("Content-Type", "text/css")
			w.Write([]byte("body { background: url(/bg.png); }"))
		case "/bg.png":
			w.Header().Set("Content-Type", "image/png")
			w.Write([]byte{0x89, 0x50, 0x4E, 0x47})
		default:
			http.NotFound(w, r)
		}
	}))
	defer ts.Close()

	t.Run("inline CSS", func(t *testing.T) {
		html := `<html><head><link rel="stylesheet" href="/style.css"></head><body></body></html>`
		result, err := InlineResources(context.Background(), html, DefaultInlineOptions(ts.URL))
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		if !strings.Contains(result, "<style>body { color: red; }</style>") {
			t.Error("CSS should be inlined")
		}
		if strings.Contains(result, `<link rel="stylesheet"`) {
			t.Error("link tag should be replaced")
		}
	})

	t.Run("inline JS", func(t *testing.T) {
		html := `<html><head></head><body><script src="/script.js"></script></body></html>`
		result, err := InlineResources(context.Background(), html, DefaultInlineOptions(ts.URL))
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		if !strings.Contains(result, "console.log") {
			t.Error("JS should be inlined")
		}
		if strings.Contains(result, `src="/script.js"`) {
			t.Error("src attribute should be removed")
		}
	})

	t.Run("inline images", func(t *testing.T) {
		html := `<html><head></head><body><img src="/image.png"></body></html>`
		result, err := InlineResources(context.Background(), html, DefaultInlineOptions(ts.URL))
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		if !strings.Contains(result, "data:image/png;base64,") {
			t.Error("image should be converted to data URI")
		}
	})

	t.Run("skip existing data URIs", func(t *testing.T) {
		dataURI := "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
		html := `<html><head></head><body><img src="` + dataURI + `"></body></html>`
		result, err := InlineResources(context.Background(), html, DefaultInlineOptions(ts.URL))
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		// Original data URI should be preserved
		if !strings.Contains(result, dataURI) {
			t.Error("existing data URI should be preserved")
		}
	})

	t.Run("adds base tag", func(t *testing.T) {
		html := `<html><head></head><body></body></html>`
		result, err := InlineResources(context.Background(), html, DefaultInlineOptions(ts.URL))
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		if !strings.Contains(result, `<base href="`) {
			t.Error("base tag should be added")
		}
	})

	t.Run("does not duplicate base tag", func(t *testing.T) {
		html := `<html><head><base href="https://original.com"></head><body></body></html>`
		result, err := InlineResources(context.Background(), html, DefaultInlineOptions(ts.URL))
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		// Count base tags
		count := strings.Count(result, "<base")
		if count != 1 {
			t.Errorf("should have exactly 1 base tag, got %d", count)
		}
	})

	t.Run("handles 404 gracefully", func(t *testing.T) {
		html := `<html><head><link rel="stylesheet" href="/nonexistent.css"></head><body></body></html>`
		result, err := InlineResources(context.Background(), html, DefaultInlineOptions(ts.URL))
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		// Should not crash, link tag should remain
		if result == "" {
			t.Error("should return non-empty result even with 404")
		}
	})

	t.Run("respects InlineCSS option", func(t *testing.T) {
		html := `<html><head><link rel="stylesheet" href="/style.css"></head><body></body></html>`
		opts := DefaultInlineOptions(ts.URL)
		opts.InlineCSS = false

		result, err := InlineResources(context.Background(), html, opts)
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		if strings.Contains(result, "<style>") {
			t.Error("CSS should not be inlined when InlineCSS is false")
		}
	})

	t.Run("respects InlineJS option", func(t *testing.T) {
		html := `<html><head></head><body><script src="/script.js"></script></body></html>`
		opts := DefaultInlineOptions(ts.URL)
		opts.InlineJS = false

		result, err := InlineResources(context.Background(), html, opts)
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		if strings.Contains(result, "console.log") {
			t.Error("JS should not be inlined when InlineJS is false")
		}
	})

	t.Run("respects InlineImages option", func(t *testing.T) {
		html := `<html><head></head><body><img src="/image.png"></body></html>`
		opts := DefaultInlineOptions(ts.URL)
		opts.InlineImages = false

		result, err := InlineResources(context.Background(), html, opts)
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		if strings.Contains(result, "data:image/png") {
			t.Error("images should not be inlined when InlineImages is false")
		}
	})

	t.Run("removes srcset", func(t *testing.T) {
		html := `<html><head></head><body><img src="/image.png" srcset="/image-2x.png 2x"></body></html>`
		result, err := InlineResources(context.Background(), html, DefaultInlineOptions(ts.URL))
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}

		if strings.Contains(result, "srcset") {
			t.Error("srcset attribute should be removed")
		}
	})
}

func TestInlineCSSURLs(t *testing.T) {
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "image/png")
		w.Write([]byte{0x89, 0x50, 0x4E, 0x47})
	}))
	defer ts.Close()

	tests := []struct {
		name    string
		css     string
		wantHas string
	}{
		{
			name:    "simple url",
			css:     "body { background: url(/bg.png); }",
			wantHas: "data:image/png;base64,",
		},
		{
			name:    "url with quotes",
			css:     `body { background: url("/bg.png"); }`,
			wantHas: "data:image/png;base64,",
		},
		{
			name:    "url with single quotes",
			css:     `body { background: url('/bg.png'); }`,
			wantHas: "data:image/png;base64,",
		},
		{
			name:    "preserves data URI",
			css:     "body { background: url(data:image/gif;base64,R0lGODlhAQABA); }",
			wantHas: "url(data:image/gif;base64,R0lGODlhAQABA)",
		},
		{
			name:    "multiple urls",
			css:     "body { background: url(/bg.png); } .foo { background: url(/bg.png); }",
			wantHas: "data:image/png;base64,",
		},
	}

	client := &http.Client{Timeout: 5 * time.Second}
	opts := DefaultInlineOptions(ts.URL)

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := inlineCSSURLs(context.Background(), client, tt.css, ts.URL, opts)
			if !strings.Contains(result, tt.wantHas) {
				t.Errorf("result should contain %q, got %q", tt.wantHas, result)
			}
		})
	}
}

func TestDefaultInlineOptions(t *testing.T) {
	opts := DefaultInlineOptions("https://example.com")

	if opts.BaseURL != "https://example.com" {
		t.Errorf("BaseURL = %q, want %q", opts.BaseURL, "https://example.com")
	}
	if opts.Timeout != DefaultResourceTimeout {
		t.Errorf("Timeout = %v, want %v", opts.Timeout, DefaultResourceTimeout)
	}
	if opts.MaxResourceSize != MaxResourceSize {
		t.Errorf("MaxResourceSize = %d, want %d", opts.MaxResourceSize, MaxResourceSize)
	}
	if !opts.InlineCSS {
		t.Error("InlineCSS should be true by default")
	}
	if !opts.InlineJS {
		t.Error("InlineJS should be true by default")
	}
	if !opts.InlineImages {
		t.Error("InlineImages should be true by default")
	}
}

func TestInvalidBaseURL(t *testing.T) {
	html := `<html><head></head><body></body></html>`
	opts := InlineOptions{BaseURL: "://invalid"}

	_, err := InlineResources(context.Background(), html, opts)
	if err == nil {
		t.Fatal("expected error for invalid base URL")
	}
	if !strings.Contains(err.Error(), "invalid base URL") {
		t.Errorf("error should mention invalid base URL, got: %v", err)
	}
}

func TestInvalidHTML(t *testing.T) {
	// goquery is quite tolerant, but let's test with empty input
	result, err := InlineResources(context.Background(), "", DefaultInlineOptions("https://example.com"))
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	// Empty input should still produce valid HTML structure
	if result == "" {
		t.Error("should produce non-empty result")
	}
}

func TestIsInternalURL(t *testing.T) {
	// Temporarily disable the test bypass to verify SSRF protection works
	AllowInternalURLsForTesting = false
	defer func() { AllowInternalURLsForTesting = true }()

	tests := []struct {
		name     string
		url      string
		internal bool
	}{
		// External URLs (should NOT be blocked)
		{"external https", "https://example.com/style.css", false},
		{"external http", "http://example.com/script.js", false},
		{"external with port", "https://cdn.example.com:8080/file", false},
		{"external IP", "https://93.184.216.34/path", false},

		// Localhost (should be blocked)
		{"localhost", "http://localhost/api", true},
		{"localhost with port", "http://localhost:8080/api", true},
		{"127.0.0.1", "http://127.0.0.1/api", true},
		{"127.0.0.1 with port", "http://127.0.0.1:3000/api", true},
		{"ipv6 localhost", "http://[::1]/api", true},

		// Private IP ranges (should be blocked)
		{"private 10.x", "http://10.0.0.1/internal", true},
		{"private 172.16.x", "http://172.16.0.1/internal", true},
		{"private 192.168.x", "http://192.168.1.1/internal", true},

		// Link-local (should be blocked)
		{"link local ipv4", "http://169.254.1.1/api", true},
		{"link local ipv6", "http://[fe80::1]/api", true},

		// Internal domain suffixes (should be blocked)
		{"dot local", "http://server.local/api", true},
		{"dot localhost", "http://myapp.localhost/api", true},
		{"dot internal", "http://server.internal/api", true},
		{"dot localdomain", "http://host.localdomain/api", true},

		// Unspecified (should be blocked)
		{"unspecified ipv4", "http://0.0.0.0/api", true},

		// Empty/invalid (should be blocked - fail safe)
		{"empty host", "http:///path", true},
		{"no host", "/relative/path", true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := isInternalURL(tt.url)
			if result != tt.internal {
				t.Errorf("isInternalURL(%q) = %v, want %v", tt.url, result, tt.internal)
			}
		})
	}
}

func TestSSRFProtection(t *testing.T) {
	// Temporarily disable the test bypass to verify SSRF protection works
	AllowInternalURLsForTesting = false
	defer func() { AllowInternalURLsForTesting = true }()

	client := &http.Client{Timeout: 5 * time.Second}

	t.Run("blocks localhost fetch", func(t *testing.T) {
		_, err := fetchURL(context.Background(), client, "http://localhost/secret", 0)
		if err == nil {
			t.Fatal("expected error for localhost URL")
		}
		if !strings.Contains(err.Error(), "blocked") {
			t.Errorf("error should mention blocked, got: %v", err)
		}
	})

	t.Run("blocks private IP fetch", func(t *testing.T) {
		_, err := fetchURL(context.Background(), client, "http://192.168.1.1/admin", 0)
		if err == nil {
			t.Fatal("expected error for private IP URL")
		}
		if !strings.Contains(err.Error(), "blocked") {
			t.Errorf("error should mention blocked, got: %v", err)
		}
	})

	t.Run("blocks internal domain fetch", func(t *testing.T) {
		_, err := fetchURL(context.Background(), client, "http://server.internal/api", 0)
		if err == nil {
			t.Fatal("expected error for internal domain URL")
		}
		if !strings.Contains(err.Error(), "blocked") {
			t.Errorf("error should mention blocked, got: %v", err)
		}
	})
}
</file>

<file path=".gitignore">
bookmarkd
bookmarkd.db
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

bookmarkd is a self-hosted bookmark archiving service written in Go. It saves web pages locally by capturing rendered HTML (including JS-heavy SPAs) via Chrome/Chromium headless browser and inlining external resources (CSS, JS, images) to create self-contained offline archives.

## Common Commands

```bash
# Run the server (starts web UI + background archive workers)
go run . --port 8080 --host localhost --db bookmarkd.db --archive-workers 2

# Run all tests
go test ./...

# Run tests for a specific package
go test ./internal/core/db/...
go test ./cmd/...

# Run a single test
go test ./internal/core/db/... -run TestAddBookmark

# Archive bookmarks via CLI (instead of background workers)
go run . archive --limit=10 --headless
go run . archive --id=123 --timeout=30s

# Build
go build -o bookmarkd .
```

## Architecture

### Package Structure

- `cmd/` - Cobra CLI commands (root server command, archive subcommand)
- `internal/core/` - Core business logic
  - `archive.go` - Browser-based page capture using chromedp
  - `inline.go` - Resource inlining (CSS, JS, images → data URIs)
  - `db/` - SQLite database layer with embedded migrations
    - `events.go` - Event system for bookmark/archive lifecycle hooks
    - `bookmarks.go`, `archives.go` - Data access methods
    - `migrations/*.sql` - Embedded SQL migrations (auto-applied)
  - `web/` - HTTP server with embedded templates
    - `handlers.go` - Request handlers
    - `templates/*.html` - HTML templates
    - `static/*.css` - Static assets

### Key Patterns

**Event-Driven Archiving**: The database emits events (`OnBookmarkCreatedEvent`, `OnArchiveClearedEvent`) that trigger background archive workers. Register listeners via `db.RegisterEventListener()`.

**Embedded Assets**: Templates, static files, and migrations are embedded via `//go:embed`. Changes to these files require rebuild.

**Archive Pipeline**: `ArchiveBookmark()` → chromedp captures rendered HTML → `InlineResources()` converts external resources to data URIs → `SaveArchiveResult()` persists to SQLite.

### Web Routes

- `/` - Bookmark list (main UI)
- `/bookmarks` - POST to add, GET to list
- `/bookmarklet` - Bookmarklet installation page
- `/bookmarklet/add` - Bookmarklet endpoint
- `/bookmarks/{id}/archive` - View archived page
- `/bookmarks/{id}/archive/raw` - Raw archived HTML
- `/archives` - Archive management UI
- `/archives/{id}/refetch` - Re-queue bookmark for archiving

## Testing

Tests use the standard Go testing package. Database tests create temporary SQLite files. Web handler tests use `httptest.NewRecorder()`.
</file>

<file path="go.mod">
module github.com/seckatie/bookmarkd

go 1.25.5

require (
	github.com/PuerkitoBio/goquery v1.11.0
	github.com/chromedp/chromedp v0.14.2
	github.com/mattn/go-sqlite3 v1.14.32
	github.com/spf13/cobra v1.10.2
)

require (
	github.com/andybalholm/cascadia v1.3.3 // indirect
	github.com/chromedp/cdproto v0.0.0-20250724212937-08a3db8b4327
	github.com/chromedp/sysutil v1.1.0 // indirect
	github.com/go-json-experiment/json v0.0.0-20250725192818-e39067aee2d2 // indirect
	github.com/gobwas/httphead v0.1.0 // indirect
	github.com/gobwas/pool v0.2.1 // indirect
	github.com/gobwas/ws v1.4.0 // indirect
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/spf13/pflag v1.0.9 // indirect
	golang.org/x/net v0.47.0 // indirect
	golang.org/x/sys v0.38.0 // indirect
)
</file>

<file path="justfile">
# Bookmarkd justfile

# Default recipe
default:
    @just --list

# Build the bookmarkd binary
build:
    go build -o bookmarkd .

# Run tests
test:
    go test ./...

# Install bookmarkd to ~/.local/bin
install: build
    mkdir -p ~/.local/bin
    cp bookmarkd ~/.local/bin/bookmarkd
    chmod +x ~/.local/bin/bookmarkd
    @echo "Installed bookmarkd to ~/.local/bin/bookmarkd"
    @echo "Make sure ~/.local/bin is in your PATH"

# Uninstall bookmarkd from ~/.local/bin
uninstall:
    rm -f ~/.local/bin/bookmarkd
    @echo "Removed bookmarkd from ~/.local/bin"

# Install launchctl service (macOS)
install-service: install
    #!/usr/bin/env bash
    set -euo pipefail

    PLIST_PATH="$HOME/Library/LaunchAgents/net.mulliken.bookmarkd.plist"
    DATA_DIR="$HOME/.local/share/bookmarkd"
    LOG_DIR="$HOME/.local/share/bookmarkd/logs"

    # Create data and log directories
    mkdir -p "$DATA_DIR"
    mkdir -p "$LOG_DIR"

    # Create the plist file
    cat > "$PLIST_PATH" << EOF
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
    <plist version="1.0">
    <dict>
        <key>Label</key>
        <string>net.mulliken.bookmarkd</string>
        <key>ProgramArguments</key>
        <array>
            <string>$HOME/.local/bin/bookmarkd</string>
            <string>--db</string>
            <string>$DATA_DIR/bookmarkd.db</string>
            <string>--host</string>
            <string>localhost</string>
            <string>--port</string>
            <string>8080</string>
        </array>
        <key>RunAtLoad</key>
        <true/>
        <key>KeepAlive</key>
        <true/>
        <key>StandardOutPath</key>
        <string>$LOG_DIR/bookmarkd.log</string>
        <key>StandardErrorPath</key>
        <string>$LOG_DIR/bookmarkd.err</string>
        <key>WorkingDirectory</key>
        <string>$DATA_DIR</string>
    </dict>
    </plist>
    EOF

    echo "Created launchctl plist at $PLIST_PATH"
    echo "Data directory: $DATA_DIR"
    echo "Log directory: $LOG_DIR"
    echo ""
    echo "To start the service now, run:"
    echo "  launchctl load $PLIST_PATH"
    echo ""
    echo "To start on next login, it will load automatically."

# Uninstall launchctl service (macOS)
uninstall-service:
    #!/usr/bin/env bash
    set -euo pipefail

    PLIST_PATH="$HOME/Library/LaunchAgents/net.mulliken.bookmarkd.plist"

    if [ -f "$PLIST_PATH" ]; then
        launchctl unload "$PLIST_PATH" 2>/dev/null || true
        rm -f "$PLIST_PATH"
        echo "Removed launchctl service"
    else
        echo "Service plist not found at $PLIST_PATH"
    fi

# Start the launchctl service
start-service:
    launchctl load ~/Library/LaunchAgents/net.mulliken.bookmarkd.plist

# Stop the launchctl service
stop-service:
    launchctl unload ~/Library/LaunchAgents/net.mulliken.bookmarkd.plist

# Restart the launchctl service
restart-service: stop-service start-service

# Show service status
status-service:
    @launchctl list | grep bookmarkd || echo "Service not running"

# View service logs
logs:
    tail -f ~/.local/share/bookmarkd/logs/bookmarkd.log

# View service error logs
logs-err:
    tail -f ~/.local/share/bookmarkd/logs/bookmarkd.err

# Clean build artifacts
clean:
    rm -f bookmarkd
</file>

<file path="main.go">
/*
Copyright © 2025 NAME HERE <EMAIL ADDRESS>
*/
package main

import "github.com/seckatie/bookmarkd/cmd"

func main() {
	cmd.Execute()
}
</file>

<file path="cmd/root.go">
/*
Copyright © 2025 Katie Mulliken <katie@mulliken.net>
*/
package cmd

import (
	"context"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/seckatie/bookmarkd/internal/core"
	"github.com/seckatie/bookmarkd/internal/core/db"
	"github.com/seckatie/bookmarkd/internal/core/web"
	"github.com/spf13/cobra"
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &cobra.Command{
	Use:   "bookmarkd",
	Short: "A brief description of your application",
	Long: `A longer description that spans multiple lines and likely contains
examples and usage of using your application. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.`,
	Run: func(cmd *cobra.Command, args []string) {
		database, err := initDB(cmd)
		if err != nil {
			log.Fatalf("Failed to initialize database: %v", err)
		}
		defer func() {
			if err := database.Close(); err != nil {
				log.Printf("failed to close database: %v", err)
			}
		}()

		numWorkers, err := cmd.Flags().GetInt("archive-workers")
		if err != nil {
			log.Fatalf("Failed to get archive workers: %v", err)
		}

		// Create the work queue for the archive workers
		workQueue := make(chan db.Bookmark, numWorkers*10) // Buffer for multiple bookmarks

		// queueBookmark attempts to queue a bookmark for archiving.
		// It tries for up to 5 seconds before giving up. The bookmark will be
		// automatically retried on next startup since it remains unarchived in the DB.
		queueBookmark := func(bookmark db.Bookmark, reason string) {
			select {
			case workQueue <- bookmark:
				log.Printf("Queued bookmark %d (%s) for %s", bookmark.ID, bookmark.URL, reason)
			case <-time.After(5 * time.Second):
				log.Printf("Warning: work queue full after 5s, bookmark %d (%s) not queued for %s - will be retried on next startup",
					bookmark.ID, bookmark.URL, reason)
			}
		}

		// Register event listeners to queue bookmarks for archiving
		database.RegisterEventListener(db.OnBookmarkCreatedEvent, func(event db.Event) error {
			ev := event.(db.BookmarkCreatedEvent)
			queueBookmark(ev.Bookmark, "archiving (new)")
			return nil
		})

		database.RegisterEventListener(db.OnArchiveClearedEvent, func(event db.Event) error {
			ev := event.(db.ArchiveClearedEvent)
			log.Printf("Archive cleared for bookmark %d, queuing for re-archiving", ev.BookmarkID)
			// Fetch the bookmark to queue it
			bookmark, err := database.GetBookmark(ev.BookmarkID)
			if err != nil {
				log.Printf("Error fetching bookmark %d for re-archiving: %v", ev.BookmarkID, err)
				return err
			}
			queueBookmark(bookmark, "re-archiving")
			return nil
		})

		// Start archive workers that process bookmarks and persist results
		for i := 0; i < numWorkers; i++ {
			workerID := i
			go func() {
				log.Printf("Archive worker %d started", workerID)
				for bookmark := range workQueue {
					log.Printf("Worker %d archiving bookmark %d: %s", workerID, bookmark.ID, bookmark.URL)
					ctx := context.Background()
					if err := core.ArchiveAndPersist(ctx, database, bookmark, core.ArchiveOptions{
						Headless: true,
					}); err != nil {
						log.Printf("Worker %d: Archive failed for id=%d url=%s: %v", workerID, bookmark.ID, bookmark.URL, err)
					} else {
						log.Printf("Worker %d: Successfully archived bookmark %d", workerID, bookmark.ID)
					}
				}
				log.Printf("Archive worker %d stopped", workerID)
			}()
		}

		// On startup, check for any existing unarchived bookmarks and queue them
		go func() {
			time.Sleep(2 * time.Second) // Give the server a moment to start
			log.Println("Checking for existing unarchived bookmarks on startup...")
			bookmarks, err := database.ListBookmarksToArchive(0)
			if err != nil {
				log.Printf("Error listing bookmarks to archive: %v", err)
				return
			}
			if len(bookmarks) == 0 {
				log.Println("No existing bookmarks need archiving")
				return
			}
			log.Printf("Found %d existing unarchived bookmarks, queuing...", len(bookmarks))
			queued := 0
			for _, b := range bookmarks {
				select {
				case workQueue <- b:
					queued++
				case <-time.After(5 * time.Second):
					log.Printf("Warning: work queue full, stopped queuing at %d/%d bookmarks - remaining will be retried on next startup",
						queued, len(bookmarks))
					return
				}
			}
			log.Printf("Successfully queued all %d existing bookmarks for archiving", queued)
		}()

		// Get the host and port from the flags
		host, err := cmd.Flags().GetString("host")
		if err != nil {
			log.Fatalf("Failed to get host: %v", err)
		}
		port, err := cmd.Flags().GetInt("port")
		if err != nil {
			log.Fatalf("Failed to get port: %v", err)
		}

		// Start the web server
		web.StartServer(fmt.Sprintf("%s:%d", host, port), database)
	},
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() {
	err := rootCmd.Execute()
	if err != nil {
		os.Exit(1)
	}
}

func init() {
	rootCmd.PersistentFlags().StringP("db", "d", "bookmarkd.db", "Path to the SQLite database file")
	rootCmd.Flags().IntP("port", "p", 8080, "Port to listen on")
	rootCmd.Flags().String("host", "localhost", "Host to listen on")

	// Archive workers flags
	rootCmd.Flags().IntP("archive-workers", "w", 1, "Number of archive workers to run")
}

func initDB(cmd *cobra.Command) (*db.DB, error) {
	dbPath, err := cmd.Flags().GetString("db")
	if err != nil {
		log.Fatalf("Failed to get database path: %v", err)
	}
	database, err := db.NewSQLiteDB(dbPath)
	if err != nil {
		log.Fatalf("Failed to create database: %v", err)
	}

	if err := database.Migrate(); err != nil {
		log.Fatalf("Failed to migrate database: %v", err)
	}

	log.Println("Database migrated successfully")

	return database, nil
}
</file>

<file path="internal/core/db/archives.go">
package db

import (
	"database/sql"
	"errors"
	"fmt"
	"log"
	"time"
)

func (db *DB) QueueBookmarkForArchive(id int64) error {
	_, err := db.db.Exec(`
		UPDATE bookmarks
		SET archived_at = NULL
		WHERE id = ?
	`, id)
	return err
}

// scanBookmarks extracts Bookmark structs from SQL rows.
// This is a helper to reduce duplication across bookmark query functions.
func scanBookmarks(rows *sql.Rows) ([]Bookmark, error) {
	var out []Bookmark
	for rows.Next() {
		var b Bookmark
		if err := rows.Scan(&b.ID, &b.URL, &b.Title, &b.CreatedAt); err != nil {
			return nil, fmt.Errorf("failed to scan bookmark: %w", err)
		}
		out = append(out, b)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating bookmark rows: %w", err)
	}
	return out, nil
}

// queryBookmarks executes a bookmark query with optional limit and returns the results.
// This is a helper to reduce duplication across list functions.
func (db *DB) queryBookmarks(query string, args []any, limit int) ([]Bookmark, error) {
	if limit > 0 {
		query += " LIMIT ?"
		args = append(args, limit)
	}
	rows, err := db.db.Query(query, args...)
	if err != nil {
		return nil, err
	}
	defer func() {
		if err := rows.Close(); err != nil {
			log.Printf("failed to close rows: %v", err)
		}
	}()
	return scanBookmarks(rows)
}

func (db *DB) ListBookmarksToArchive(limit int) ([]Bookmark, error) {
	query := `
		SELECT id, url, title, created_at
		FROM bookmarks
		WHERE archived_at IS NULL
		ORDER BY created_at DESC`
	bookmarks, err := db.queryBookmarks(query, nil, limit)
	if err != nil {
		return nil, fmt.Errorf("failed to list bookmarks to archive: %w", err)
	}
	return bookmarks, nil
}

func (db *DB) ListArchivedBookmarks(limit int) ([]Bookmark, error) {
	query := `
		SELECT id, url, title, created_at
		FROM bookmarks
		WHERE archived_at IS NOT NULL
		ORDER BY archived_at DESC`
	bookmarks, err := db.queryBookmarks(query, nil, limit)
	if err != nil {
		return nil, fmt.Errorf("failed to list archived bookmarks: %w", err)
	}
	return bookmarks, nil
}

func (db *DB) ListBookmarksByArchiveStatus(status string, limit int) ([]Bookmark, error) {
	query := `
		SELECT id, url, title, created_at
		FROM bookmarks
		WHERE archive_status = ?
		ORDER BY archive_attempted_at DESC`
	bookmarks, err := db.queryBookmarks(query, []any{status}, limit)
	if err != nil {
		return nil, fmt.Errorf("failed to list bookmarks by archive status: %w", err)
	}
	return bookmarks, nil
}

func (db *DB) GetBookmarkArchive(id int64) (BookmarkArchive, error) {
	var a BookmarkArchive
	err := db.db.QueryRow(`
		SELECT
			id,
			COALESCE(archived_url, ''),
			COALESCE(archived_html, ''),
			COALESCE(archive_attempted_at, ''),
			COALESCE(archived_at, ''),
			COALESCE(archive_status, ''),
			COALESCE(archive_error, '')
		FROM bookmarks
		WHERE id = ?
	`, id).Scan(
		&a.BookmarkID,
		&a.ArchivedURL,
		&a.ArchivedHTML,
		&a.ArchiveAttemptedAt,
		&a.ArchivedAt,
		&a.ArchiveStatus,
		&a.ArchiveError,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return BookmarkArchive{}, fmt.Errorf("bookmark not found: %d", id)
		}
		return BookmarkArchive{}, fmt.Errorf("failed to get bookmark archive: %w", err)
	}
	return a, nil
}

func (db *DB) ClearBookmarkArchive(id int64) error {
	res, err := db.db.Exec(`
		UPDATE bookmarks
		SET
			archived_html = NULL,
			archived_url = NULL,
			archive_attempted_at = NULL,
			archived_at = NULL,
			archive_status = NULL,
			archive_error = NULL
		WHERE id = ?
	`, id)
	if err != nil {
		return fmt.Errorf("failed to clear bookmark archive: %w", err)
	}
	affected, err := res.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to determine rows affected: %w", err)
	}
	if affected == 0 {
		return fmt.Errorf("bookmark not found: %d", id)
	}

	// Emit event so bookmark can be queued for re-archiving
	db.emit(ArchiveClearedEvent{
		BookmarkID: id,
	})

	return nil
}

// SaveArchiveResult saves the result of an archive operation.
// Emits an ArchiveResultSavedEvent after successful save.
func (db *DB) SaveArchiveResult(id int64, attemptedAt time.Time, archivedAt *time.Time, status string, archiveErr string, archivedURL string, archivedHTML string) error {
	var archivedAtStr any = nil
	if archivedAt != nil {
		archivedAtStr = archivedAt.Format(time.RFC3339)
	}

	res, err := db.db.Exec(`
		UPDATE bookmarks
		SET
			archive_attempted_at = ?,
			archived_at = ?,
			archive_status = ?,
			archive_error = ?,
			archived_url = ?,
			archived_html = ?
		WHERE id = ?
	`,
		attemptedAt.Format(time.RFC3339),
		archivedAtStr,
		status,
		archiveErr,
		archivedURL,
		archivedHTML,
		id,
	)
	if err != nil {
		return fmt.Errorf("failed to save archive result: %w", err)
	}
	affected, err := res.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to determine rows affected: %w", err)
	}
	if affected == 0 {
		return fmt.Errorf("bookmark not found: %d", id)
	}

	db.emit(ArchiveResultSavedEvent{
		BookmarkID: id,
		Status:     status,
	})

	return nil
}
</file>

<file path="internal/core/db/bookmarks_test.go">
package db

import (
	"errors"
	"strings"
	"testing"
)

// TestAddBookmark tests bookmark creation.
func TestAddBookmark(t *testing.T) {
	db := newTestDB(t)
	t.Cleanup(func() {
		if err := db.Close(); err != nil {
			t.Errorf("failed to close db: %v", err)
		}
	})

	t.Run("creates bookmark successfully", func(t *testing.T) {
		id, err := db.AddBookmark("https://example.com", "Example Site")
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if id <= 0 {
			t.Errorf("expected positive ID, got %d", id)
		}
	})

	t.Run("assigns sequential IDs", func(t *testing.T) {
		id1, _ := db.AddBookmark("https://site1.com", "Site 1")
		id2, _ := db.AddBookmark("https://site2.com", "Site 2")

		if id2 <= id1 {
			t.Errorf("expected id2 (%d) > id1 (%d)", id2, id1)
		}
	})
}

// TestGetBookmark tests retrieving a single bookmark.
func TestGetBookmark(t *testing.T) {
	db := newTestDB(t)
	t.Cleanup(func() {
		if err := db.Close(); err != nil {
			t.Errorf("failed to close db: %v", err)
		}
	})

	t.Run("retrieves existing bookmark", func(t *testing.T) {
		id, _ := db.AddBookmark("https://example.com", "Example Site")

		b, err := db.GetBookmark(id)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if b.ID != id {
			t.Errorf("expected ID %d, got %d", id, b.ID)
		}
		if b.URL != "https://example.com" {
			t.Errorf("expected URL 'https://example.com', got %q", b.URL)
		}
		if b.Title != "Example Site" {
			t.Errorf("expected Title 'Example Site', got %q", b.Title)
		}
		if b.CreatedAt == "" {
			t.Error("expected CreatedAt to be set")
		}
	})

	t.Run("returns error for non-existent bookmark", func(t *testing.T) {
		_, err := db.GetBookmark(99999)
		if err == nil {
			t.Error("expected error for non-existent bookmark, got nil")
		}
		if !strings.Contains(err.Error(), "not found") {
			t.Errorf("expected 'not found' error, got %v", err)
		}
	})
}

// TestListBookmarks tests listing bookmarks.
func TestListBookmarks(t *testing.T) {
	db := newTestDB(t)
	t.Cleanup(func() {
		if err := db.Close(); err != nil {
			t.Errorf("failed to close db: %v", err)
		}
	})

	t.Run("returns empty list when no bookmarks", func(t *testing.T) {
		bookmarks, err := db.ListBookmarks(0)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if len(bookmarks) != 0 {
			t.Errorf("expected empty list, got %d items", len(bookmarks))
		}
	})

	t.Run("returns all bookmarks", func(t *testing.T) {
		if _, err := db.AddBookmark("https://site1.com", "Site 1"); err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}
		if _, err := db.AddBookmark("https://site2.com", "Site 2"); err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}
		if _, err := db.AddBookmark("https://site3.com", "Site 3"); err != nil {
			t.Fatalf("failed to add bookmark: %v", err)
		}

		bookmarks, err := db.ListBookmarks(0)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if len(bookmarks) != 3 {
			t.Errorf("expected 3 bookmarks, got %d", len(bookmarks))
		}
	})

	t.Run("respects limit", func(t *testing.T) {
		// Database already has 3 bookmarks from previous subtest
		bookmarks, err := db.ListBookmarks(2)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if len(bookmarks) != 2 {
			t.Errorf("expected 2 bookmarks with limit, got %d", len(bookmarks))
		}
	})

	t.Run("orders by created_at DESC", func(t *testing.T) {
		// Create fresh database for this test
		db2 := newTestDB(t)
		t.Cleanup(func() {
			if err := db2.Close(); err != nil {
				t.Errorf("failed to close db2: %v", err)
			}
		})

		// Insert bookmarks with explicit different timestamps to ensure ordering
		_, err := db2.db.Exec("INSERT INTO bookmarks (url, title, created_at) VALUES (?, ?, ?)",
			"https://first.com", "First", "2024-01-01T00:00:00Z")
		if err != nil {
			t.Fatalf("failed to insert first bookmark: %v", err)
		}
		_, err = db2.db.Exec("INSERT INTO bookmarks (url, title, created_at) VALUES (?, ?, ?)",
			"https://second.com", "Second", "2024-01-02T00:00:00Z")
		if err != nil {
			t.Fatalf("failed to insert second bookmark: %v", err)
		}
		_, err = db2.db.Exec("INSERT INTO bookmarks (url, title, created_at) VALUES (?, ?, ?)",
			"https://third.com", "Third", "2024-01-03T00:00:00Z")
		if err != nil {
			t.Fatalf("failed to insert third bookmark: %v", err)
		}

		bookmarks, _ := db2.ListBookmarks(0)

		// Most recent (latest created_at) should be first
		if bookmarks[0].Title != "Third" {
			t.Errorf("expected most recent bookmark first, got %q", bookmarks[0].Title)
		}
		if bookmarks[1].Title != "Second" {
			t.Errorf("expected second most recent bookmark second, got %q", bookmarks[1].Title)
		}
		if bookmarks[2].Title != "First" {
			t.Errorf("expected oldest bookmark last, got %q", bookmarks[2].Title)
		}
	})
}

// TestUpdateBookmark tests updating a bookmark.
func TestUpdateBookmark(t *testing.T) {
	db := newTestDB(t)
	defer db.Close()

	t.Run("updates existing bookmark", func(t *testing.T) {
		id, _ := db.AddBookmark("https://old.com", "Old Title")

		err := db.UpdateBookmark(id, "https://new.com", "New Title")
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}

		b, _ := db.GetBookmark(id)
		if b.URL != "https://new.com" {
			t.Errorf("expected URL 'https://new.com', got %q", b.URL)
		}
		if b.Title != "New Title" {
			t.Errorf("expected Title 'New Title', got %q", b.Title)
		}
	})

	t.Run("returns error for non-existent bookmark", func(t *testing.T) {
		err := db.UpdateBookmark(99999, "https://new.com", "New Title")
		if err == nil {
			t.Error("expected error for non-existent bookmark, got nil")
		}
		if !strings.Contains(err.Error(), "not found") {
			t.Errorf("expected 'not found' error, got %v", err)
		}
	})
}

// TestDeleteBookmark tests deleting a bookmark.
func TestDeleteBookmark(t *testing.T) {
	db := newTestDB(t)
	defer db.Close()

	t.Run("deletes existing bookmark", func(t *testing.T) {
		id, _ := db.AddBookmark("https://example.com", "To Delete")

		err := db.DeleteBookmark(id)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}

		_, err = db.GetBookmark(id)
		if err == nil {
			t.Error("expected error when getting deleted bookmark")
		}
	})

	t.Run("returns error for non-existent bookmark", func(t *testing.T) {
		err := db.DeleteBookmark(99999)
		if err == nil {
			t.Error("expected error for non-existent bookmark, got nil")
		}
		if !strings.Contains(err.Error(), "not found") {
			t.Errorf("expected 'not found' error, got %v", err)
		}
	})
}

// TestValidateBookmarkURL tests URL validation.
func TestValidateBookmarkURL(t *testing.T) {
	tests := []struct {
		name    string
		url     string
		wantErr bool
		errMsg  string
	}{
		{"valid http URL", "http://example.com", false, ""},
		{"valid https URL", "https://example.com", false, ""},
		{"valid URL with path", "https://example.com/path/to/page", false, ""},
		{"valid URL with query", "https://example.com?foo=bar", false, ""},
		{"valid URL with port", "https://example.com:8080/path", false, ""},
		{"empty URL", "", true, "empty URL"},
		{"no scheme", "example.com", true, "scheme must be http or https"},
		{"ftp scheme", "ftp://example.com", true, "scheme must be http or https"},
		{"javascript scheme", "javascript:alert(1)", true, "scheme must be http or https"},
		{"file scheme", "file:///etc/passwd", true, "scheme must be http or https"},
		{"missing host", "https://", true, "missing host"},
		{"data URI", "data:text/html,<h1>hi</h1>", true, "scheme must be http or https"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := ValidateBookmarkURL(tt.url)
			if tt.wantErr {
				if err == nil {
					t.Fatal("expected error, got nil")
				}
				if !errors.Is(err, ErrInvalidURL) {
					t.Errorf("expected ErrInvalidURL, got %v", err)
				}
				if tt.errMsg != "" && !strings.Contains(err.Error(), tt.errMsg) {
					t.Errorf("error should contain %q, got %v", tt.errMsg, err)
				}
			} else {
				if err != nil {
					t.Errorf("unexpected error: %v", err)
				}
			}
		})
	}
}

// TestAddBookmarkValidation tests that AddBookmark validates URLs.
func TestAddBookmarkValidation(t *testing.T) {
	db := newTestDB(t)
	defer db.Close()

	t.Run("rejects invalid URL", func(t *testing.T) {
		_, err := db.AddBookmark("not-a-url", "Invalid")
		if err == nil {
			t.Fatal("expected error for invalid URL, got nil")
		}
		if !errors.Is(err, ErrInvalidURL) {
			t.Errorf("expected ErrInvalidURL, got %v", err)
		}
	})

	t.Run("rejects ftp URL", func(t *testing.T) {
		_, err := db.AddBookmark("ftp://example.com", "FTP Site")
		if err == nil {
			t.Fatal("expected error for ftp URL, got nil")
		}
		if !errors.Is(err, ErrInvalidURL) {
			t.Errorf("expected ErrInvalidURL, got %v", err)
		}
	})

	t.Run("rejects empty URL", func(t *testing.T) {
		_, err := db.AddBookmark("", "No URL")
		if err == nil {
			t.Fatal("expected error for empty URL, got nil")
		}
		if !errors.Is(err, ErrInvalidURL) {
			t.Errorf("expected ErrInvalidURL, got %v", err)
		}
	})

	t.Run("accepts valid http URL", func(t *testing.T) {
		id, err := db.AddBookmark("http://example.com", "HTTP Site")
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if id <= 0 {
			t.Errorf("expected positive ID, got %d", id)
		}
	})

	t.Run("accepts valid https URL", func(t *testing.T) {
		id, err := db.AddBookmark("https://example.com", "HTTPS Site")
		if err != nil {
			t.Fatalf("unexpected error: %v", err)
		}
		if id <= 0 {
			t.Errorf("expected positive ID, got %d", id)
		}
	})
}
</file>

<file path="internal/core/db/bookmarks.go">
package db

import (
	"database/sql"
	"errors"
	"fmt"
	"log"
	"net/url"
	"time"
)

// ErrInvalidURL is returned when a bookmark URL fails validation.
var ErrInvalidURL = errors.New("invalid URL")

// ValidateBookmarkURL validates that a URL is acceptable for bookmarking.
// It requires the URL to have http or https scheme and a non-empty host.
func ValidateBookmarkURL(urlStr string) error {
	if urlStr == "" {
		return fmt.Errorf("%w: empty URL", ErrInvalidURL)
	}

	u, err := url.Parse(urlStr)
	if err != nil {
		return fmt.Errorf("%w: %v", ErrInvalidURL, err)
	}

	if u.Scheme != "http" && u.Scheme != "https" {
		return fmt.Errorf("%w: scheme must be http or https, got %q", ErrInvalidURL, u.Scheme)
	}

	if u.Host == "" {
		return fmt.Errorf("%w: missing host", ErrInvalidURL)
	}

	return nil
}

// ------------------------------
// Bookmark methods
// ------------------------------

func (db *DB) GetBookmark(id int64) (Bookmark, error) {
	var b Bookmark
	err := db.db.QueryRow("SELECT id, url, title, created_at FROM bookmarks WHERE id = ?", id).
		Scan(&b.ID, &b.URL, &b.Title, &b.CreatedAt)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return Bookmark{}, fmt.Errorf("bookmark not found: %d", id)
		}
		return Bookmark{}, fmt.Errorf("failed to get bookmark: %w", err)
	}
	return b, nil
}

// AddBookmark adds a new bookmark to the database and returns the ID of the new bookmark.
//
// It validates the URL before inserting and returns ErrInvalidURL if validation fails.
// It returns the new bookmark ID (>0) on success.
// Emits a BookmarkCreatedEvent after successful insert.
func (db *DB) AddBookmark(url string, title string) (int64, error) {
	if err := ValidateBookmarkURL(url); err != nil {
		return 0, err
	}

	createdAt := time.Now().Format(time.RFC3339)
	result, err := db.db.Exec(
		"INSERT INTO bookmarks (url, title, created_at) VALUES (?, ?, ?)",
		url,
		title,
		createdAt,
	)
	if err != nil {
		return 0, fmt.Errorf("failed to add bookmark: %w", err)
	}
	id, err := result.LastInsertId()
	if err != nil {
		return 0, fmt.Errorf("failed to get last insert ID: %w", err)
	}

	db.emit(BookmarkCreatedEvent{
		Bookmark: Bookmark{
			ID:        id,
			URL:       url,
			Title:     title,
			CreatedAt: createdAt,
		},
	})

	return id, nil
}

func (db *DB) ListBookmarks(limit int) ([]Bookmark, error) {
	query := `
		SELECT id, url, title, created_at
		FROM bookmarks
		ORDER BY created_at DESC
	`
	var rows *sql.Rows
	var err error
	if limit > 0 {
		rows, err = db.db.Query(query+" LIMIT ?", limit)
	} else {
		rows, err = db.db.Query(query)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to list bookmarks: %w", err)
	}
	defer func() {
		if err := rows.Close(); err != nil {
			log.Printf("failed to close rows: %v", err)
		}
	}()

	var out []Bookmark
	for rows.Next() {
		var b Bookmark
		if err := rows.Scan(&b.ID, &b.URL, &b.Title, &b.CreatedAt); err != nil {
			return nil, fmt.Errorf("failed to scan bookmark: %w", err)
		}
		out = append(out, b)
	}
	return out, nil
}

// UpdateBookmark updates a bookmark's URL and title.
// Emits a BookmarkUpdatedEvent after successful update.
func (db *DB) UpdateBookmark(id int64, url string, title string) error {
	res, err := db.db.Exec("UPDATE bookmarks SET url = ?, title = ? WHERE id = ?", url, title, id)
	if err != nil {
		return fmt.Errorf("failed to update bookmark: %w", err)
	}
	affected, err := res.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to determine rows affected: %w", err)
	}
	if affected == 0 {
		return fmt.Errorf("bookmark not found: %d", id)
	}

	// Fetch the updated bookmark to emit in the event
	b, err := db.GetBookmark(id)
	if err == nil {
		db.emit(BookmarkUpdatedEvent{Bookmark: b})
	}

	return nil
}

// DeleteBookmark removes a bookmark from the database.
// Emits a BookmarkDeletedEvent after successful deletion.
func (db *DB) DeleteBookmark(id int64) error {
	// Fetch bookmark before deletion to include in event
	b, _ := db.GetBookmark(id)

	res, err := db.db.Exec("DELETE FROM bookmarks WHERE id = ?", id)
	if err != nil {
		return fmt.Errorf("failed to delete bookmark: %w", err)
	}
	affected, err := res.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to determine rows affected: %w", err)
	}
	if affected == 0 {
		return fmt.Errorf("bookmark not found: %d", id)
	}

	// If we couldn't fetch earlier, at least include the ID
	if b.ID == 0 {
		b.ID = id
	}
	db.emit(BookmarkDeletedEvent{Bookmark: b})

	return nil
}
</file>

<file path="internal/core/web/templates/archive_item.html">
{{/* archive_item.html: single archive item with optional polling support */}}
<div class="archive-item" 
     id="archive-{{ .ID }}"
     {{ if .IsArchiving }}
     hx-get="/archives/{{ .ID }}/status"
     hx-trigger="load delay:2s"
     hx-swap="outerHTML"
     {{ end }}>
    <div class="archive-header">
        <div class="archive-title">
            <a href="{{ .URL }}" target="_blank" rel="noopener">{{ .Title }}</a>
        </div>
        <div class="archive-actions">
            {{ if .IsArchiving }}
                <span class="spinner spinner-sm" aria-hidden="true"></span>
                <span class="archiving-text">Archiving…</span>
            {{ else if eq .ArchiveStatus "ok" }}
                <span class="status-dot status-ok" title="Archived {{ .ArchivedAt }}"></span>
                <a href="/bookmarks/{{ .ID }}/archive" class="view-link">View</a>
            {{ else if eq .ArchiveStatus "error" }}
                <span class="status-dot status-error" title="Archive failed"></span>
            {{ else }}
                <span class="status-dot status-pending" title="Not archived"></span>
            {{ end }}
            <button class="refetch"
                    hx-post="/archives/{{ .ID }}/refetch"
                    hx-target="#archive-{{ .ID }}"
                    hx-swap="outerHTML"
                    hx-disabled-elt="this"
                    hx-indicator="find .btn-indicator"
                    {{ if .IsArchiving }}disabled{{ end }}
                    title="Clear archive and queue for re-archiving">
                <span class="btn-indicator htmx-indicator spinner spinner-sm" aria-hidden="true"></span>
                Refetch
            </button>
        </div>
    </div>
    <div class="archive-url">{{ .URL }}</div>
    {{ if .ArchivedAt }}
        <div class="archive-meta">
            Archived: {{ .ArchivedAt }}
            {{ if .ArchiveAttemptedAt }}| Last attempt: {{ .ArchiveAttemptedAt }}{{ end }}
        </div>
    {{ else if .ArchiveAttemptedAt }}
        <div class="archive-meta">Last attempt: {{ .ArchiveAttemptedAt }}</div>
    {{ end }}
    {{ if and (eq .ArchiveStatus "error") .ArchiveError }}
        <div class="archive-error">{{ .ArchiveError }}</div>
    {{ end }}
</div>
</file>

<file path="internal/core/web/templates/archives_list.html">
{{/* archives_list.html: htmx fragment for listing archive status of all bookmarks */}}
{{ if .archives }}
    {{ range .archives }}
        <div class="archive-item" 
             id="archive-{{ .ID }}"
             {{ if .IsArchiving }}
             hx-get="/archives/{{ .ID }}/status"
             hx-trigger="load delay:2s"
             hx-swap="outerHTML"
             {{ end }}>
            <div class="archive-header">
                <div class="archive-title">
                    <a href="{{ .URL }}" target="_blank" rel="noopener">{{ .Title }}</a>
                </div>
                <div class="archive-actions">
                    {{ if .IsArchiving }}
                        <span class="spinner spinner-sm" aria-hidden="true"></span>
                        <span class="archiving-text">Archiving…</span>
                    {{ else if eq .ArchiveStatus "ok" }}
                        <span class="status-dot status-ok" title="Archived {{ .ArchivedAt }}"></span>
                        <a href="/bookmarks/{{ .ID }}/archive" class="view-link">View</a>
                    {{ else if eq .ArchiveStatus "error" }}
                        <span class="status-dot status-error" title="Archive failed"></span>
                    {{ else }}
                        <span class="status-dot status-pending" title="Not archived"></span>
                    {{ end }}
                    <button class="refetch"
                            hx-post="/archives/{{ .ID }}/refetch"
                            hx-target="#archive-{{ .ID }}"
                            hx-swap="outerHTML"
                            hx-disabled-elt="this"
                            hx-indicator="find .btn-indicator"
                            {{ if .IsArchiving }}disabled{{ end }}
                            title="Clear archive and queue for re-archiving">
                        <span class="btn-indicator htmx-indicator spinner spinner-sm" aria-hidden="true"></span>
                        Refetch
                    </button>
                </div>
            </div>
            <div class="archive-url">{{ .URL }}</div>
            {{ if .ArchivedAt }}
                <div class="archive-meta">
                    Archived: {{ .ArchivedAt }}
                    {{ if .ArchiveAttemptedAt }}| Last attempt: {{ .ArchiveAttemptedAt }}{{ end }}
                </div>
            {{ else if .ArchiveAttemptedAt }}
                <div class="archive-meta">Last attempt: {{ .ArchiveAttemptedAt }}</div>
            {{ end }}
            {{ if and (eq .ArchiveStatus "error") .ArchiveError }}
                <div class="archive-error">{{ .ArchiveError }}</div>
            {{ end }}
        </div>
    {{ end }}
{{ else }}
    <div class="empty">No bookmarks yet. Add some from the <a href="/">main page</a>.</div>
{{ end }}
</file>

<file path="internal/core/web/templates/bookmarklet_add.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Adding Bookmark...</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/static/app.css">
  <style>
    :root {
      --bg: #0b0f17;
      --panel: rgba(255, 255, 255, 0.06);
      --panel-2: rgba(255, 255, 255, 0.10);
      --text: rgba(255, 255, 255, 0.92);
      --muted: rgba(255, 255, 255, 0.70);
      --border: rgba(255, 255, 255, 0.14);
      --link: #8ab4ff;
      --accent: #7ee787;
      --danger: #ff6b6b;
      --shadow: 0 16px 48px rgba(0,0,0,0.35);
      --radius: 14px;
    }
    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f6f7fb;
        --panel: rgba(0, 0, 0, 0.04);
        --panel-2: rgba(0, 0, 0, 0.06);
        --text: rgba(10, 18, 35, 0.92);
        --muted: rgba(10, 18, 35, 0.68);
        --border: rgba(10, 18, 35, 0.14);
        --link: #1b66ff;
        --accent: #137333;
        --danger: #b42318;
        --shadow: 0 16px 48px rgba(10,18,35,0.12);
      }
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 18px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background:
        radial-gradient(900px 500px at 100% 0%, rgba(126,231,135,0.14), transparent 55%),
        var(--bg);
      color: var(--text);
      line-height: 1.5;
    }
    .card {
      max-width: 520px;
      margin: 24px auto;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      text-align: center;
    }
    .card-body { padding: 18px; }
    h2 { margin: 0 0 8px; font-size: 16px; }
    .muted { color: var(--muted); font-size: 12px; }
    .spinner {
      width: 22px;
      height: 22px;
      border: 2px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin: 14px auto 10px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .success, .error {
      margin-top: 12px;
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      font-size: 12px;
    }
    .success { border-color: rgba(126,231,135,0.35); }
    .error { border-color: rgba(255,107,107,0.35); }
    a { color: var(--link); text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <div class="card">
    <div class="card-body">
      <h2>Adding bookmark…</h2>
      <div class="spinner" aria-hidden="true"></div>
      <div id="status" class="muted">One moment.</div>
    </div>
  </div>
  
  <form id="bookmark-form" method="POST" action="/bookmarks" style="display:none;">
    <input type="hidden" name="url" value="{{ .URL }}">
    <input type="hidden" name="title" value="{{ .Title }}">
  </form>

  <script>
    (function() {
      var form = document.getElementById('bookmark-form');
      var status = document.getElementById('status');
      
      // Submit the form via fetch
      fetch(form.action, {
        method: 'POST',
        body: new FormData(form),
        credentials: 'same-origin'
      })
      .then(function(response) {
        if (response.ok) {
          status.innerHTML = '<div class="success"><b>Saved.</b> You can close this window.<div style="margin-top:6px;"><a href="/" target="_blank" rel="noopener">Open bookmarkd</a></div><div class="muted" style="margin-top:6px;">This window will try to close automatically.</div></div>';
          document.querySelector('.spinner').style.display = 'none';
          setTimeout(function() { window.close(); }, 2000);
        } else {
          throw new Error('Failed to add bookmark');
        }
      })
      .catch(function(err) {
        status.innerHTML = '<div class="error"><b>Could not save.</b><div class="muted" style="margin-top:6px;">' + err.message + '</div><div style="margin-top:10px;"><a href="/" target="_blank" rel="noopener">Open bookmarkd</a></div></div>';
        document.querySelector('.spinner').style.display = 'none';
      });
    })();
  </script>
</body>
</html>
</file>

<file path="internal/core/web/server_test.go">
package web

import (
	"testing"

	"github.com/seckatie/bookmarkd/internal/core/db"
)

// newTestDB creates a new in-memory SQLite database for testing.
func newTestDB(t *testing.T) *db.DB {
	t.Helper()
	database, err := db.NewSQLiteDB(":memory:")
	if err != nil {
		t.Fatalf("failed to create test database: %v", err)
	}
	if err := database.Migrate(); err != nil {
		t.Fatalf("failed to migrate test database: %v", err)
	}
	return database
}

// newTestServer creates a new Server instance for testing.
func newTestServer(t *testing.T) *Server {
	t.Helper()
	database := newTestDB(t)
	server, err := newServer(database)
	if err != nil {
		t.Fatalf("failed to create test server: %v", err)
	}
	return server
}

// TestNewServer tests server initialization.
func TestNewServer(t *testing.T) {
	t.Run("creates server successfully", func(t *testing.T) {
		database := newTestDB(t)
		t.Cleanup(func() {
			if err := database.Close(); err != nil {
				t.Errorf("failed to close database: %v", err)
			}
		})

		server, err := newServer(database)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}

		if server.db == nil {
			t.Error("expected db to be set")
		}
		if server.templates == nil {
			t.Error("expected templates to be loaded")
		}
		if server.staticFS == nil {
			t.Error("expected staticFS to be set")
		}
	})

	t.Run("loads all required templates", func(t *testing.T) {
		database := newTestDB(t)
		t.Cleanup(func() {
			if err := database.Close(); err != nil {
				t.Errorf("failed to close database: %v", err)
			}
		})

		server, _ := newServer(database)

		requiredTemplates := []string{
			"index.html",
			"bookmarks.html",
			"viewer.html",
			"archives.html",
			"archives_list.html",
			"archive_item.html",
			"bookmarklet.html",
			"bookmarklet_add.html",
			"nav.html",
		}

		for _, name := range requiredTemplates {
			if server.templates.Lookup(name) == nil {
				t.Errorf("expected template %q to be loaded", name)
			}
		}
	})
}
</file>

<file path="internal/core/archive.go">
package core

import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/PuerkitoBio/goquery"
	"github.com/chromedp/cdproto/page"
	"github.com/chromedp/chromedp"
	"github.com/seckatie/bookmarkd/internal/core/db"
)

// ArchiveOptions controls how a bookmark page is fetched and captured.
//
// This uses a real Chrome/Chromium browser (via the DevTools protocol) so that
// JS-heavy pages have a chance to fully render before we snapshot the final HTML.
type ArchiveOptions struct {
	// ChromePath optionally overrides the Chrome/Chromium executable path.
	// If empty, chromedp will try to find a browser on PATH / default locations.
	ChromePath string
	// Headless controls whether Chrome runs without a visible window.
	// Set to false to debug scraping in a real window ("headful").
	Headless bool
	// Timeout is the per-page deadline for navigation + rendering + capture.
	// If <= 0, a sensible default is used.
	Timeout time.Duration
	// WaitSelector optionally waits for a CSS selector to become visible before
	// capturing the page. This is useful for SPAs or sites that render late.
	WaitSelector string
}

// ArchiveResult is the captured output of archiving a single bookmark page.
type ArchiveResult struct {
	// FinalURL is the browser's final URL after redirects.
	FinalURL string
	// Title is the document title if available (may be empty).
	Title string
	// HTML is the final rendered document HTML (outerHTML of <html>).
	HTML string
}

// ArchiveRunOptions describes a higher-level archive run: either archive a single
// bookmark by ID, or archive a batch of unarchived bookmarks.
type ArchiveRunOptions struct {
	// ID, if > 0, archives only the bookmark with this ID.
	ID int64
	// Limit bounds the number of bookmarks archived when archiving in batch mode.
	// If <= 0, archives all unarchived bookmarks.
	Limit int
	// Options are passed through to the underlying browser capture.
	Options ArchiveOptions
}

// ArchiveRunResult reports the outcome of an archive run.
type ArchiveRunResult struct {
	Attempted int
	Succeeded int
	Failed    int
}

// ArchiveBookmark loads a URL in Chrome and returns the final rendered HTML.
//
// The function:
// - navigates to the provided URL
// - waits for <body> to be ready (and optionally opts.WaitSelector to be visible)
// - captures final URL, document.title, and <html> outerHTML
//
// Notes:
//   - This does not attempt to bypass paywalls/CAPTCHAs/login walls; failures are
//     returned as errors.
//   - For pages that set a blank title, we fall back to parsing <title> from HTML.
func ArchiveBookmark(ctx context.Context, url string, opts ArchiveOptions) (ArchiveResult, error) {
	log.Printf("Archiving bookmark %s", url)
	log.Printf("Opts: %+v", opts)
	if opts.Timeout <= 0 {
		opts.Timeout = DefaultArchiveTimeout
	}

	allocatorOpts := append([]chromedp.ExecAllocatorOption{}, chromedp.DefaultExecAllocatorOptions[:]...)
	allocatorOpts = append(allocatorOpts,
		chromedp.NoDefaultBrowserCheck,
		chromedp.NoFirstRun,
	)
	if opts.ChromePath != "" {
		allocatorOpts = append(allocatorOpts, chromedp.ExecPath(opts.ChromePath))
	}
	if opts.Headless {
		allocatorOpts = append(allocatorOpts, chromedp.Headless)
	} else {
		allocatorOpts = append(allocatorOpts, chromedp.Flag("headless", false))
	}

	allocCtx, cancelAlloc := chromedp.NewExecAllocator(ctx, allocatorOpts...)
	defer cancelAlloc()

	browserCtx, cancelBrowser := chromedp.NewContext(allocCtx)
	defer cancelBrowser()

	runCtx, cancelRun := context.WithTimeout(browserCtx, opts.Timeout)
	defer cancelRun()

	var html string
	var title string
	var finalURL string

	// Wait for network idle to ensure all resources are loaded
	waitForNetworkIdle := func(ctx context.Context) error {
		// Enable lifecycle events
		if err := page.SetLifecycleEventsEnabled(true).Do(ctx); err != nil {
			return err
		}

		// Create a channel to receive lifecycle events
		ch := make(chan struct{})
		chromedp.ListenTarget(ctx, func(ev interface{}) {
			if e, ok := ev.(*page.EventLifecycleEvent); ok {
				if e.Name == "networkIdle" {
					select {
					case ch <- struct{}{}:
					default:
					}
				}
			}
		})

		// Navigate and wait for network idle
		if err := chromedp.Navigate(url).Do(ctx); err != nil {
			return err
		}

		// Wait for networkIdle event or timeout
		select {
		case <-ch:
			log.Printf("Network idle reached for %s", url)
		case <-ctx.Done():
			return ctx.Err()
		}

		return nil
	}

	actions := []chromedp.Action{
		chromedp.ActionFunc(waitForNetworkIdle),
		chromedp.WaitReady("body", chromedp.ByQuery),
	}
	if strings.TrimSpace(opts.WaitSelector) != "" {
		actions = append(actions, chromedp.WaitVisible(opts.WaitSelector, chromedp.ByQuery))
	}
	// Small delay to allow any final JS execution after network idle
	actions = append(actions,
		chromedp.Sleep(DefaultNetworkIdleDelay),
		chromedp.Location(&finalURL),
		chromedp.Title(&title),
		chromedp.OuterHTML("html", &html, chromedp.ByQuery),
	)

	if err := chromedp.Run(runCtx, actions...); err != nil {
		return ArchiveResult{}, err
	}

	// Some pages leave document.title blank; fall back to parsing HTML if needed.
	if strings.TrimSpace(title) == "" && strings.TrimSpace(html) != "" {
		if doc, err := goquery.NewDocumentFromReader(strings.NewReader(html)); err == nil {
			title = strings.TrimSpace(doc.Find("title").First().Text())
		}
	}

	return ArchiveResult{
		FinalURL: finalURL,
		Title:    title,
		HTML:     html,
	}, nil
}

// ArchiveAndPersist archives a bookmark URL and stores the result in the database.
//
// On success, it writes:
// - archive_attempted_at
// - archived_at
// - archive_status = "ok"
// - archived_url, archived_html
//
// On failure, it still records:
// - archive_attempted_at
// - archive_status = "error"
// - archive_error
func ArchiveAndPersist(ctx context.Context, database *db.DB, b db.Bookmark, opts ArchiveOptions) error {
	attemptedAt := time.Now()

	res, err := ArchiveBookmark(ctx, b.URL, opts)
	if err != nil {
		saveErr := database.SaveArchiveResult(b.ID, attemptedAt, nil, ArchiveStatusError, err.Error(), "", "")
		if saveErr != nil {
			return fmt.Errorf("archive failed (%v) and saving failure failed (%v)", err, saveErr)
		}
		return err
	}

	// Inline external resources to make HTML self-contained
	log.Printf("Inlining resources for bookmark id=%d", b.ID)
	inlineOpts := DefaultInlineOptions(res.FinalURL)
	inlinedHTML, err := InlineResources(ctx, res.HTML, inlineOpts)
	if err != nil {
		log.Printf("Warning: failed to inline resources for id=%d: %v (using original HTML)", b.ID, err)
		inlinedHTML = res.HTML
	}

	archivedAt := time.Now()
	if err := database.SaveArchiveResult(b.ID, attemptedAt, &archivedAt, ArchiveStatusOK, "", res.FinalURL, inlinedHTML); err != nil {
		return err
	}

	// Optional: if the stored title is empty, you could update it here in the future.
	_ = res.Title
	log.Printf("Archived bookmark id=%d url=%s", b.ID, b.URL)
	return nil
}

// RunArchive is the top-level archiving workflow.
//
// It supports:
// - single-bookmark mode (opts.ID > 0)
// - batch mode (archives bookmarks where archived_at IS NULL, optionally limited)
//
// It returns an ArchiveRunResult plus an error if any bookmarks failed to archive.
func RunArchive(ctx context.Context, database *db.DB, opts ArchiveRunOptions) (ArchiveRunResult, error) {
	if opts.ID > 0 {
		b, err := database.GetBookmark(opts.ID)
		if err != nil {
			return ArchiveRunResult{}, err
		}
		if err := ArchiveAndPersist(ctx, database, b, opts.Options); err != nil {
			return ArchiveRunResult{Attempted: 1, Failed: 1}, err
		}
		return ArchiveRunResult{Attempted: 1, Succeeded: 1}, nil
	}

	bookmarks, err := database.ListBookmarksToArchive(opts.Limit)
	if err != nil {
		return ArchiveRunResult{}, err
	}
	if len(bookmarks) == 0 {
		log.Println("No bookmarks to archive.")
		return ArchiveRunResult{}, nil
	}

	log.Printf("Archiving %d bookmark(s)...", len(bookmarks))
	var res ArchiveRunResult
	for _, b := range bookmarks {
		res.Attempted++
		if err := ArchiveAndPersist(ctx, database, b, opts.Options); err != nil {
			res.Failed++
			log.Printf("Archive failed for id=%d url=%s: %v", b.ID, b.URL, err)
			continue
		}
		res.Succeeded++
	}

	if res.Failed > 0 {
		return res, fmt.Errorf("archiving finished with %d failure(s)", res.Failed)
	}

	log.Println("Archiving finished successfully.")
	return res, nil
}
</file>

<file path="internal/core/inline.go">
package core

import (
	"context"
	"encoding/base64"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/PuerkitoBio/goquery"
)

// AllowInternalURLsForTesting disables SSRF protection for testing purposes.
// This should only be set to true in test code, never in production.
var AllowInternalURLsForTesting = false

// isInternalURL checks if a URL points to a private/internal network address.
// This helps prevent SSRF attacks by blocking requests to localhost, private IPs, etc.
func isInternalURL(urlStr string) bool {
	if AllowInternalURLsForTesting {
		return false
	}

	u, err := url.Parse(urlStr)
	if err != nil {
		return true // Fail safe - block if we can't parse
	}

	host := u.Hostname()
	if host == "" {
		return true // No host means it's not a valid external URL
	}

	// Check for localhost variants
	lowerHost := strings.ToLower(host)
	if lowerHost == "localhost" || lowerHost == "127.0.0.1" || lowerHost == "::1" {
		return true
	}

	// Check for internal domain suffixes
	if strings.HasSuffix(lowerHost, ".local") ||
		strings.HasSuffix(lowerHost, ".localhost") ||
		strings.HasSuffix(lowerHost, ".internal") ||
		strings.HasSuffix(lowerHost, ".localdomain") {
		return true
	}

	// Parse as IP and check for private ranges
	ip := net.ParseIP(host)
	if ip != nil {
		// Check for loopback, private, and link-local addresses
		if ip.IsLoopback() || ip.IsPrivate() || ip.IsLinkLocalUnicast() || ip.IsLinkLocalMulticast() {
			return true
		}
		// Block unspecified addresses (0.0.0.0, ::)
		if ip.IsUnspecified() {
			return true
		}
	}

	return false
}

// InlineOptions controls how resources are inlined into archived HTML.
type InlineOptions struct {
	// BaseURL is used to resolve relative URLs in the HTML.
	BaseURL string
	// Timeout is the per-resource fetch timeout.
	Timeout time.Duration
	// MaxResourceSize is the maximum size of a single resource to inline (bytes).
	// Resources larger than this are skipped. 0 means no limit.
	MaxResourceSize int64
	// InlineImages controls whether images are converted to data URIs.
	InlineImages bool
	// InlineCSS controls whether external stylesheets are inlined.
	InlineCSS bool
	// InlineJS controls whether external scripts are inlined.
	InlineJS bool
}

// DefaultInlineOptions returns sensible defaults for inlining.
func DefaultInlineOptions(baseURL string) InlineOptions {
	return InlineOptions{
		BaseURL:         baseURL,
		Timeout:         DefaultResourceTimeout,
		MaxResourceSize: MaxResourceSize,
		InlineImages:    true,
		InlineCSS:       true,
		InlineJS:        true,
	}
}

// resourceInliner handles the inlining of external resources into HTML.
// It encapsulates the context, HTTP client, base URL, and options needed
// for fetching and processing resources.
type resourceInliner struct {
	ctx     context.Context
	client  *http.Client
	baseURL *url.URL
	opts    InlineOptions
}

// newResourceInliner creates a new resourceInliner with the given configuration.
func newResourceInliner(ctx context.Context, opts InlineOptions) (*resourceInliner, error) {
	baseURL, err := url.Parse(opts.BaseURL)
	if err != nil {
		return nil, fmt.Errorf("invalid base URL: %w", err)
	}

	return &resourceInliner{
		ctx:     ctx,
		client:  &http.Client{Timeout: opts.Timeout},
		baseURL: baseURL,
		opts:    opts,
	}, nil
}

// logFetchError logs fetch errors, filtering out common 404 errors.
func (ri *resourceInliner) logFetchError(resourceType, url string, err error) {
	if !strings.Contains(err.Error(), "HTTP 404") {
		log.Printf("Failed to fetch %s %s: %v", resourceType, url, err)
	}
}

// inlineStylesheets converts external <link rel="stylesheet"> tags to inline <style> tags.
func (ri *resourceInliner) inlineStylesheets(doc *goquery.Document) {
	doc.Find("link[rel='stylesheet']").Each(func(i int, s *goquery.Selection) {
		href, exists := s.Attr("href")
		if !exists || href == "" {
			return
		}

		cssURL := resolveURL(ri.baseURL, href)
		if cssURL == "" {
			return
		}

		css, err := fetchResource(ri.ctx, ri.client, cssURL, ri.opts.MaxResourceSize)
		if err != nil {
			ri.logFetchError("CSS", cssURL, err)
			return
		}

		// Process CSS to inline any url() references
		css = inlineCSSURLs(ri.ctx, ri.client, css, cssURL, ri.opts)

		// Replace <link> with <style>
		s.ReplaceWithHtml(fmt.Sprintf("<style>%s</style>", css))
	})
}

// inlineScripts converts external <script src> tags to inline scripts.
func (ri *resourceInliner) inlineScripts(doc *goquery.Document) {
	doc.Find("script[src]").Each(func(i int, s *goquery.Selection) {
		src, exists := s.Attr("src")
		if !exists || src == "" {
			return
		}

		jsURL := resolveURL(ri.baseURL, src)
		if jsURL == "" {
			return
		}

		js, err := fetchResource(ri.ctx, ri.client, jsURL, ri.opts.MaxResourceSize)
		if err != nil {
			ri.logFetchError("JS", jsURL, err)
			return
		}

		// Replace script with inline version
		s.RemoveAttr("src")
		s.SetText(js)
	})
}

// inlineImages converts image src attributes to data URIs.
func (ri *resourceInliner) inlineImages(doc *goquery.Document) {
	doc.Find("img[src]").Each(func(i int, s *goquery.Selection) {
		src, exists := s.Attr("src")
		if !exists || src == "" {
			return
		}

		// Skip data URIs
		if strings.HasPrefix(src, "data:") {
			return
		}

		imgURL := resolveURL(ri.baseURL, src)
		if imgURL == "" {
			return
		}

		dataURI, err := fetchAsDataURI(ri.ctx, ri.client, imgURL, ri.opts.MaxResourceSize)
		if err != nil {
			ri.logFetchError("image", imgURL, err)
			return
		}

		s.SetAttr("src", dataURI)
	})

	// Remove srcset attributes since they're complex and we've inlined src
	doc.Find("img[srcset], source[srcset]").Each(func(i int, s *goquery.Selection) {
		s.RemoveAttr("srcset")
	})
}

// inlineBackgroundImages processes style attributes to inline CSS url() references.
func (ri *resourceInliner) inlineBackgroundImages(doc *goquery.Document) {
	doc.Find("[style]").Each(func(i int, s *goquery.Selection) {
		style, _ := s.Attr("style")
		if strings.Contains(style, "url(") {
			newStyle := inlineCSSURLs(ri.ctx, ri.client, style, ri.opts.BaseURL, ri.opts)
			s.SetAttr("style", newStyle)
		}
	})
}

// addBaseTag adds a <base> tag for any remaining relative URLs that couldn't be inlined.
func (ri *resourceInliner) addBaseTag(doc *goquery.Document) {
	head := doc.Find("head")
	if head.Length() > 0 && doc.Find("base").Length() == 0 {
		head.PrependHtml(fmt.Sprintf(`<base href="%s">`, ri.baseURL.String()))
	}
}

// InlineResources processes HTML and inlines external resources.
// This makes the archived HTML self-contained and viewable offline.
func InlineResources(ctx context.Context, html string, opts InlineOptions) (string, error) {
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(html))
	if err != nil {
		return "", fmt.Errorf("failed to parse HTML: %w", err)
	}

	inliner, err := newResourceInliner(ctx, opts)
	if err != nil {
		return "", err
	}

	if opts.InlineCSS {
		inliner.inlineStylesheets(doc)
	}
	if opts.InlineJS {
		inliner.inlineScripts(doc)
	}
	if opts.InlineImages {
		inliner.inlineImages(doc)
	}
	inliner.inlineBackgroundImages(doc)
	inliner.addBaseTag(doc)

	result, err := doc.Html()
	if err != nil {
		return "", fmt.Errorf("failed to serialize HTML: %w", err)
	}

	return result, nil
}

// resolveURL resolves a potentially relative URL against a base URL.
func resolveURL(base *url.URL, ref string) string {
	if ref == "" {
		return ""
	}

	// Skip data URIs and javascript:
	if strings.HasPrefix(ref, "data:") || strings.HasPrefix(ref, "javascript:") {
		return ""
	}

	refURL, err := url.Parse(ref)
	if err != nil {
		return ""
	}

	resolved := base.ResolveReference(refURL)
	return resolved.String()
}

// fetchResult holds the result of fetching a URL.
type fetchResult struct {
	data        []byte
	contentType string
}

// fetchURL is the shared HTTP fetch implementation.
// It handles request creation, size limits, and response reading.
// It blocks requests to internal/private network addresses to prevent SSRF attacks.
func fetchURL(ctx context.Context, client *http.Client, urlStr string, maxSize int64) (*fetchResult, error) {
	// SSRF protection: block requests to internal network addresses
	if isInternalURL(urlStr) {
		return nil, fmt.Errorf("blocked request to internal URL: %s", urlStr)
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, urlStr, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("User-Agent", UserAgent)

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer func() {
		if err := resp.Body.Close(); err != nil {
			log.Printf("failed to close response body: %v", err)
		}
	}()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("HTTP %d", resp.StatusCode)
	}

	var reader io.Reader = resp.Body
	if maxSize > 0 {
		reader = io.LimitReader(resp.Body, maxSize)
	}

	data, err := io.ReadAll(reader)
	if err != nil {
		return nil, err
	}

	contentType := resp.Header.Get("Content-Type")
	if contentType == "" {
		contentType = http.DetectContentType(data)
	}

	return &fetchResult{data: data, contentType: contentType}, nil
}

// fetchResource fetches a URL and returns its content as a string.
func fetchResource(ctx context.Context, client *http.Client, urlStr string, maxSize int64) (string, error) {
	result, err := fetchURL(ctx, client, urlStr, maxSize)
	if err != nil {
		return "", err
	}
	return string(result.data), nil
}

// fetchAsDataURI fetches a URL and returns it as a data URI.
func fetchAsDataURI(ctx context.Context, client *http.Client, urlStr string, maxSize int64) (string, error) {
	result, err := fetchURL(ctx, client, urlStr, maxSize)
	if err != nil {
		return "", err
	}

	contentType := result.contentType
	// Strip charset suffix for data URI
	if idx := strings.Index(contentType, ";"); idx > 0 {
		contentType = strings.TrimSpace(contentType[:idx])
	}

	encoded := base64.StdEncoding.EncodeToString(result.data)
	return fmt.Sprintf("data:%s;base64,%s", contentType, encoded), nil
}

// inlineCSSURLs processes CSS and inlines any url() references.
func inlineCSSURLs(ctx context.Context, client *http.Client, css string, baseURLStr string, opts InlineOptions) string {
	baseURL, err := url.Parse(baseURLStr)
	if err != nil {
		return css
	}

	// Process url() patterns by building result incrementally
	var result strings.Builder
	remaining := css

	for {
		startIdx := strings.Index(remaining, "url(")
		if startIdx == -1 {
			result.WriteString(remaining)
			break
		}

		// Write everything before url(
		result.WriteString(remaining[:startIdx])

		// Find the closing parenthesis
		afterURL := remaining[startIdx+4:]
		endIdx := strings.Index(afterURL, ")")
		if endIdx == -1 {
			result.WriteString(remaining[startIdx:])
			break
		}

		urlContent := afterURL[:endIdx]

		// Strip quotes
		urlContent = strings.TrimSpace(urlContent)
		urlContent = strings.Trim(urlContent, `"'`)

		// Skip data URIs - keep them as-is
		if strings.HasPrefix(urlContent, "data:") {
			result.WriteString(remaining[startIdx : startIdx+4+endIdx+1])
			remaining = remaining[startIdx+4+endIdx+1:]
			continue
		}

		// Resolve and fetch
		resolved := resolveURL(baseURL, urlContent)
		if resolved == "" {
			// Keep original
			result.WriteString(remaining[startIdx : startIdx+4+endIdx+1])
			remaining = remaining[startIdx+4+endIdx+1:]
			continue
		}

		dataURI, err := fetchAsDataURI(ctx, client, resolved, opts.MaxResourceSize)
		if err != nil {
			// Only log non-404 errors (404s are common for deleted/moved resources)
			if !strings.Contains(err.Error(), "HTTP 404") {
				log.Printf("Failed to fetch CSS resource %s: %v", resolved, err)
			}
			// Keep original URL
			result.WriteString(remaining[startIdx : startIdx+4+endIdx+1])
			remaining = remaining[startIdx+4+endIdx+1:]
			continue
		}

		// Write the inlined url()
		result.WriteString(fmt.Sprintf("url(%s)", dataURI))
		remaining = remaining[startIdx+4+endIdx+1:]
	}

	return result.String()
}
</file>

<file path="internal/core/web/templates/archives.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Archive Manager - bookmarkd</title>
    <script src="https://unpkg.com/htmx.org@1.9.11"></script>
    <link rel="stylesheet" href="/static/app.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        :root {
            --bg: #0b0f17;
            --panel: rgba(255, 255, 255, 0.06);
            --panel-2: rgba(255, 255, 255, 0.10);
            --text: rgba(255, 255, 255, 0.92);
            --muted: rgba(255, 255, 255, 0.70);
            --border: rgba(255, 255, 255, 0.14);
            --link: #8ab4ff;
            --accent: #7ee787;
            --danger: #ff6b6b;
            --shadow: 0 16px 48px rgba(0,0,0,0.35);
            --radius: 14px;
            --maxw: 980px;
        }
        @media (prefers-color-scheme: light) {
            :root {
                --bg: #f6f7fb;
                --panel: rgba(0, 0, 0, 0.04);
                --panel-2: rgba(0, 0, 0, 0.06);
                --text: rgba(10, 18, 35, 0.92);
                --muted: rgba(10, 18, 35, 0.68);
                --border: rgba(10, 18, 35, 0.14);
                --link: #1b66ff;
                --accent: #137333;
                --danger: #b42318;
                --shadow: 0 16px 48px rgba(10,18,35,0.12);
            }
        }
        * { box-sizing: border-box; }
        html, body { height: 100%; }
        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            color: var(--text);
            background:
                radial-gradient(1200px 600px at 20% -10%, rgba(138,180,255,0.25), transparent 60%),
                radial-gradient(900px 500px at 100% 0%, rgba(126,231,135,0.18), transparent 55%),
                var(--bg);
            line-height: 1.5;
        }
        a { color: var(--link); text-decoration: none; }
        a:hover { text-decoration: underline; }
        .container {
            max-width: var(--maxw);
            margin: 0 auto;
            padding: 32px 18px 56px;
        }
        header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 16px;
            margin-bottom: 22px;
            flex-wrap: wrap;
        }
        .brand h1 {
            font-size: 28px;
            margin: 0;
            letter-spacing: -0.02em;
        }
        .brand p {
            margin: 6px 0 0;
            color: var(--muted);
            font-size: 14px;
        }
        .nav-links {
            display: flex;
            gap: 16px;
            align-items: center;
        }
        .card {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden;
        }
        .card-header {
            padding: 16px 16px 12px;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(180deg, var(--panel-2), transparent);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .card-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            gap: 12px;
        }
        .card-header h2 {
            margin: 0;
            font-size: 15px;
            letter-spacing: 0.01em;
            text-transform: uppercase;
            color: var(--muted);
        }
        .card-body { padding: 16px; }
        .list {
            display: grid;
            gap: 10px;
        }
        .archive-item {
            padding: 12px 12px 10px;
            border: 1px solid var(--border);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.04);
        }
        @media (prefers-color-scheme: light) {
            .archive-item { background: rgba(255, 255, 255, 0.75); }
        }
        .archive-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 4px;
        }
        .archive-title { font-weight: 700; flex: 1; min-width: 0; }
        .archive-title a { color: var(--text); }
        .archive-title a:hover { color: var(--link); text-decoration: none; }
        .archive-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }
        .status-ok { background: var(--accent); }
        .status-error { background: var(--danger); }
        .status-pending { background: var(--muted); opacity: 0.4; }
        .view-link {
            font-size: 12px;
            color: var(--link);
            white-space: nowrap;
        }
        .archiving-text {
            font-size: 12px;
            color: var(--muted);
            white-space: nowrap;
        }
        .archive-url {
            color: var(--muted);
            font-size: 12px;
            word-break: break-all;
        }
        .archive-meta {
            margin-top: 8px;
            font-size: 12px;
            color: var(--muted);
        }
        .archive-error {
            margin-top: 6px;
            padding: 8px 10px;
            background: rgba(255, 107, 107, 0.1);
            border: 1px solid rgba(255, 107, 107, 0.3);
            border-radius: 8px;
            font-size: 12px;
            color: var(--danger);
        }
        button {
            appearance: none;
            border: 1px solid rgba(126,231,135,0.45);
            background: rgba(126,231,135,0.14);
            color: var(--text);
            padding: 6px 10px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 12px;
            cursor: pointer;
        }
        button:hover { background: rgba(126,231,135,0.18); }
        button:active { transform: translateY(1px); }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        button.refetch {
            border-color: rgba(138, 180, 255, 0.45);
            background: rgba(138, 180, 255, 0.14);
        }
        button.refetch:hover { background: rgba(138, 180, 255, 0.22); }
        .refresh-btn {
            background: transparent;
            border: 1px solid var(--border);
            padding: 6px 10px;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .refresh-btn:hover { background: var(--panel); }
        .empty {
            padding: 14px;
            border: 1px dashed var(--border);
            border-radius: 12px;
            color: var(--muted);
            text-align: center;
            background: rgba(255,255,255,0.04);
        }
        .loading { color: var(--muted); text-align: center; padding: 14px; }
        /* Loading indicator */
        .htmx-indicator { display: none; }
        .htmx-request .htmx-indicator { display: inline-block; }
        .htmx-request.htmx-indicator { display: inline-block; }
        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        .spinner-sm {
            width: 14px;
            height: 14px;
            border-width: 2px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        .list-container { position: relative; }
        .list-container.htmx-request::after {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--bg);
            opacity: 0.5;
            border-radius: 12px;
        }
        footer {
            margin-top: 18px;
            color: var(--muted);
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            gap: 12px;
            flex-wrap: wrap;
        }
        .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
        .htmx-request button { opacity: 0.6; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="brand">
                <h1>bookmarkd</h1>
                <p>Archive manager</p>
            </div>
            {{ template "nav" . }}
        </header>

        <main>
            <section class="card">
                <div class="card-header">
                    <div class="card-header-row">
                        <h2>All Archives</h2>
                        <button class="refresh-btn"
                                hx-get="/archives/list"
                                hx-target="#archives-list"
                                hx-swap="innerHTML"
                                hx-indicator=".list-indicator">
                            <span class="list-indicator htmx-indicator spinner"></span>
                            <span>Refresh</span>
                        </button>
                    </div>
                </div>
                <div class="card-body">
                    <div id="archives-list"
                         class="list list-container"
                         hx-get="/archives/list"
                         hx-trigger="load, every 30s"
                         hx-swap="innerHTML"
                         hx-indicator=".list-indicator">
                        <div class="loading">
                            <div class="spinner" style="margin: 0 auto;"></div>
                            <div style="margin-top: 8px;">Loading archives...</div>
                        </div>
                    </div>
                </div>
            </section>
        </main>

        {{ template "footer" . }}
    </div>
</body>
</html>
</file>

<file path="internal/core/web/templates/bookmarklet.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bookmarklet - Add to bookmarkd</title>
  <script src="https://unpkg.com/htmx.org@1.9.11"></script>
  <link rel="stylesheet" href="/static/app.css">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      --bg: #0b0f17;
      --panel: rgba(255, 255, 255, 0.06);
      --panel-2: rgba(255, 255, 255, 0.10);
      --text: rgba(255, 255, 255, 0.92);
      --muted: rgba(255, 255, 255, 0.70);
      --border: rgba(255, 255, 255, 0.14);
      --link: #8ab4ff;
      --accent: #7ee787;
      --danger: #ff6b6b;
      --shadow: 0 16px 48px rgba(0,0,0,0.35);
      --radius: 14px;
      --maxw: 980px;
    }
    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f6f7fb;
        --panel: rgba(0, 0, 0, 0.04);
        --panel-2: rgba(0, 0, 0, 0.06);
        --text: rgba(10, 18, 35, 0.92);
        --muted: rgba(10, 18, 35, 0.68);
        --border: rgba(10, 18, 35, 0.14);
        --link: #1b66ff;
        --accent: #137333;
        --danger: #b42318;
        --shadow: 0 16px 48px rgba(10,18,35,0.12);
      }
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 20% -10%, rgba(138,180,255,0.25), transparent 60%),
        radial-gradient(900px 500px at 100% 0%, rgba(126,231,135,0.18), transparent 55%),
        var(--bg);
      line-height: 1.5;
    }
    a { color: var(--link); text-decoration: none; }
    a:hover { text-decoration: underline; }

    .container {
      max-width: var(--maxw);
      margin: 0 auto;
      padding: 32px 18px 56px;
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 16px;
      margin-bottom: 22px;
      flex-wrap: wrap;
    }
    .brand h1 {
      font-size: 28px;
      margin: 0;
      letter-spacing: -0.02em;
    }
    .brand p {
      margin: 6px 0 0;
      color: var(--muted);
      font-size: 14px;
    }
    .nav-links {
      display: flex;
      gap: 16px;
      align-items: center;
      flex-wrap: wrap;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    .card-header {
      padding: 16px 16px 12px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, var(--panel-2), transparent);
    }
    .card-header h2 {
      margin: 0;
      font-size: 15px;
      letter-spacing: 0.01em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .card-body { padding: 16px; }

    .bookmarklet-link {
      display: inline-block;
      border: 1px solid rgba(138, 180, 255, 0.45);
      background: rgba(138, 180, 255, 0.14);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 700;
      transition: background 0.18s;
      cursor: grab;
    }
    .bookmarklet-link:hover {
      background: rgba(138, 180, 255, 0.22);
      text-decoration: none;
    }
    code {
      background: rgba(255,255,255,0.08);
      color: var(--text);
      padding: 2px 6px;
      border-radius: 6px;
      font-size: 12px;
    }
    .muted { color: var(--muted); }
    .stack { display: grid; gap: 12px; }
    .note {
      padding: 12px 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(255,255,255,0.04);
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="brand">
        <h1>bookmarkd</h1>
        <p>Bookmarklet</p>
      </div>
      {{ template "nav" . }}
    </header>

    <main class="card">
      <div class="card-header">
        <h2>Install</h2>
      </div>
      <div class="card-body">
        <div class="stack">
          <div class="muted">
            Drag this button to your bookmarks bar. Then click it on any page you want to save.
          </div>

          <div>
            <a class="bookmarklet-link"
               href="javascript:(function(){var bookmarkdURL='http://localhost:8080';var url=encodeURIComponent(window.location.href);var title=encodeURIComponent(document.title);var win=window.open(bookmarkdURL+'/bookmarklet/add?url='+url+'&title='+title,'_blank','width=600,height=400');if(!win){alert('Please allow popups for this site');}})();">
              Add to bookmarkd
            </a>
          </div>

          <div class="note">
            <div><b>Safari:</b> if you see a popup blocked warning, allow popups for the site you're bookmarking, then try again.</div>
          </div>

          <div class="note">
            <div><b>Server URL:</b> this bookmarklet is configured for <code>http://localhost:8080</code>.</div>
            <div class="muted" style="margin-top: 6px;">
              If your bookmarkd runs elsewhere, edit the bookmark after saving it and change <code>bookmarkdURL</code>.
            </div>
          </div>
        </div>
      </div>
    </main>

    {{ template "footer" . }}
  </div>
</body>
</html>
</file>

<file path="internal/core/web/templates/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>bookmarkd</title>
    <script src="https://unpkg.com/htmx.org@1.9.11"></script>
    <link rel="stylesheet" href="/static/app.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        :root {
            --bg: #0b0f17;
            --panel: rgba(255, 255, 255, 0.06);
            --panel-2: rgba(255, 255, 255, 0.10);
            --text: rgba(255, 255, 255, 0.92);
            --muted: rgba(255, 255, 255, 0.70);
            --border: rgba(255, 255, 255, 0.14);
            --link: #8ab4ff;
            --accent: #7ee787;
            --danger: #ff6b6b;
            --shadow: 0 16px 48px rgba(0,0,0,0.35);
            --radius: 14px;
            --maxw: 980px;
        }
        @media (prefers-color-scheme: light) {
            :root {
                --bg: #f6f7fb;
                --panel: rgba(0, 0, 0, 0.04);
                --panel-2: rgba(0, 0, 0, 0.06);
                --text: rgba(10, 18, 35, 0.92);
                --muted: rgba(10, 18, 35, 0.68);
                --border: rgba(10, 18, 35, 0.14);
                --link: #1b66ff;
                --accent: #137333;
                --danger: #b42318;
                --shadow: 0 16px 48px rgba(10,18,35,0.12);
            }
        }
        * { box-sizing: border-box; }
        html, body { height: 100%; }
        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            color: var(--text);
            background:
                radial-gradient(1200px 600px at 20% -10%, rgba(138,180,255,0.25), transparent 60%),
                radial-gradient(900px 500px at 100% 0%, rgba(126,231,135,0.18), transparent 55%),
                var(--bg);
            line-height: 1.5;
        }
        a { color: var(--link); text-decoration: none; }
        a:hover { text-decoration: underline; }
        .container {
            max-width: var(--maxw);
            margin: 0 auto;
            padding: 32px 18px 56px;
        }
        header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 16px;
            margin-bottom: 22px;
        }
        .brand h1 {
            font-size: 28px;
            margin: 0;
            letter-spacing: -0.02em;
        }
        .brand p {
            margin: 6px 0 0;
            color: var(--muted);
            font-size: 14px;
        }
        .pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: 999px;
            background: var(--panel);
            font-size: 13px;
            color: var(--muted);
            white-space: nowrap;
        }
        main {
            display: grid;
            grid-template-columns: 1fr;
            gap: 16px;
        }
        @media (min-width: 860px) {
            main { grid-template-columns: 360px 1fr; gap: 18px; }
        }
        .card {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden;
        }
        .card-header {
            padding: 16px 16px 12px;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(180deg, var(--panel-2), transparent);
        }
        .card-header h2 {
            margin: 0;
            font-size: 15px;
            letter-spacing: 0.01em;
            text-transform: uppercase;
            color: var(--muted);
        }
        .card-body { padding: 16px; }
        form { display: grid; gap: 12px; }
        label { display: grid; gap: 6px; font-size: 13px; color: var(--muted); }
        input {
            width: 100%;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: rgba(255,255,255,0.06);
            padding: 10px 11px;
            color: var(--text);
            outline: none;
        }
        @media (prefers-color-scheme: light) {
            input { background: rgba(255,255,255,0.75); }
        }
        input:focus {
            border-color: rgba(138, 180, 255, 0.55);
            box-shadow: 0 0 0 4px rgba(138, 180, 255, 0.18);
        }
        .row { display: grid; gap: 12px; }
        .row.two { grid-template-columns: 1fr; }
        @media (min-width: 860px) {
            .row.two { grid-template-columns: 1fr; }
        }
        .actions { display: flex; gap: 10px; align-items: center; }
        button {
            appearance: none;
            border: 1px solid rgba(126,231,135,0.45);
            background: rgba(126,231,135,0.14);
            color: var(--text);
            padding: 10px 12px;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
        }
        button:hover { background: rgba(126,231,135,0.18); }
        button:active { transform: translateY(1px); }
        .hint { font-size: 12px; color: var(--muted); }
        .list {
            display: grid;
            gap: 10px;
        }
        .bookmark-item {
            padding: 12px 12px 10px;
            border: 1px solid var(--border);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.04);
        }
        @media (prefers-color-scheme: light) {
            .bookmark-item { background: rgba(255, 255, 255, 0.75); }
        }
        .bookmark-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 4px;
        }
        .bookmark-title { font-weight: 700; flex: 1; min-width: 0; }
        .bookmark-title a { color: var(--text); }
        .bookmark-title a:hover { color: var(--link); text-decoration: none; }
        .bookmark-status {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }
        .status-ok { background: var(--accent); }
        .status-error { background: var(--danger); }
        .status-pending { background: var(--muted); opacity: 0.4; }
        .archive-link {
            font-size: 12px;
            color: var(--link);
            white-space: nowrap;
        }
        .bookmark-url {
            color: var(--muted);
            font-size: 12px;
            word-break: break-all;
        }
        .empty {
            padding: 14px;
            border: 1px dashed var(--border);
            border-radius: 12px;
            color: var(--muted);
            text-align: center;
            background: rgba(255,255,255,0.04);
        }
        .loading { color: var(--muted); text-align: center; padding: 14px; }

        /* Loading indicator */
        .htmx-indicator {
            display: none;
        }
        .htmx-request .htmx-indicator {
            display: inline-block;
        }
        .htmx-request.htmx-indicator {
            display: inline-block;
        }
        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Button loading state */
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        button .spinner {
            width: 14px;
            height: 14px;
            border-width: 2px;
            vertical-align: middle;
            margin-right: 6px;
        }

        /* List loading overlay */
        .list-container {
            position: relative;
        }
        .list-container.htmx-request::after {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--bg);
            opacity: 0.5;
            border-radius: 12px;
        }

        /* Refresh button */
        .refresh-btn {
            background: transparent;
            border: 1px solid var(--border);
            padding: 6px 10px;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .refresh-btn:hover {
            background: var(--panel);
        }
        .card-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        footer {
            margin-top: 18px;
            color: var(--muted);
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            gap: 12px;
            flex-wrap: wrap;
        }
        .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="brand">
                <h1>bookmarkd</h1>
                <p>A fast bookmark manager demo using HTMX + Go</p>
            </div>
            {{ template "nav" . }}
        </header>

        <main>
            <section class="card">
                <div class="card-header">
                    <h2>Add bookmark</h2>
                </div>
                <div class="card-body">
                    <form id="add-bookmark-form"
                          hx-post="/bookmarks"
                          hx-target="#bookmarks-list"
                          hx-swap="innerHTML"
                          hx-disabled-elt="find button"
                          hx-indicator="find .btn-indicator"
                          hx-on::after-request="if(event.detail.successful){ this.reset(); }">
                        <label>
                            URL
                            <input type="url" name="url" placeholder="https://example.com" required autocomplete="url">
                        </label>
                        <label>
                            Title
                            <input type="text" name="title" placeholder="Example title" required autocomplete="off">
                        </label>
                        <div class="actions">
                            <button type="submit">
                                <span class="btn-indicator htmx-indicator spinner"></span>
                                Add
                            </button>
                            <div class="hint">Tip: paste a URL first, then a short title.</div>
                        </div>
                    </form>
                </div>
            </section>

            <section class="card">
                <div class="card-header">
                    <div class="card-header-row">
                        <h2>Your bookmarks</h2>
                        <button class="refresh-btn"
                                hx-get="/bookmarks"
                                hx-target="#bookmarks-list"
                                hx-swap="innerHTML"
                                hx-indicator=".list-indicator">
                            <span class="list-indicator htmx-indicator spinner"></span>
                            <span>Refresh</span>
                        </button>
                    </div>
                </div>
                <div class="card-body">
                    <div id="bookmarks-list"
                         class="list list-container"
                         hx-get="/bookmarks"
                         hx-trigger="load, every 30s"
                         hx-swap="innerHTML"
                         hx-indicator=".list-indicator">
                        <div class="loading">
                            <div class="spinner" style="margin: 0 auto;"></div>
                            <div style="margin-top: 8px;">Loading bookmarks...</div>
                        </div>
                    </div>
                </div>
            </section>
        </main>

        {{ template "footer" . }}
    </div>
</body>
</html>
</file>

<file path="internal/core/web/templates/viewer.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{{ .Title }} - Archive Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/static/app.css">
    <style>
        :root {
            --bg: #0b0f17;
            --panel: rgba(255, 255, 255, 0.06);
            --panel-2: rgba(255, 255, 255, 0.10);
            --text: rgba(255, 255, 255, 0.92);
            --muted: rgba(255, 255, 255, 0.70);
            --border: rgba(255, 255, 255, 0.14);
            --link: #8ab4ff;
            --accent: #7ee787;
        }
        @media (prefers-color-scheme: light) {
            :root {
                --bg: #f6f7fb;
                --panel: rgba(0, 0, 0, 0.04);
                --panel-2: rgba(0, 0, 0, 0.06);
                --text: rgba(10, 18, 35, 0.92);
                --muted: rgba(10, 18, 35, 0.68);
                --border: rgba(10, 18, 35, 0.14);
                --link: #1b66ff;
                --accent: #137333;
            }
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; }
        body {
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
            color: var(--text);
            background:
                radial-gradient(1200px 600px at 20% -10%, rgba(138,180,255,0.22), transparent 60%),
                radial-gradient(900px 500px at 100% 0%, rgba(126,231,135,0.16), transparent 55%),
                var(--bg);
            display: flex;
            flex-direction: column;
        }
        .navbar {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 12px 18px;
            background: var(--panel);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }
        .nav-links {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-left: auto;
        }
        .back-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--panel-2);
            color: var(--text);
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
        }
        .back-btn:hover {
            background: var(--panel);
            text-decoration: none;
        }
        .bookmark-info {
            flex: 1;
            min-width: 0;
        }
        .bookmark-info h1 {
            font-size: 16px;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .bookmark-info .original-url {
            font-size: 12px;
            color: var(--muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .bookmark-info .original-url a {
            color: var(--link);
            text-decoration: none;
        }
        .bookmark-info .original-url a:hover {
            text-decoration: underline;
        }
        .viewer-frame {
            flex: 1;
            border: none;
            background: #fff;
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <a href="/" class="back-btn">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                <path fill-rule="evenodd" d="M7.78 12.53a.75.75 0 01-1.06 0L2.47 8.28a.75.75 0 010-1.06l4.25-4.25a.75.75 0 011.06 1.06L4.81 7h7.44a.75.75 0 010 1.5H4.81l2.97 2.97a.75.75 0 010 1.06z"/>
            </svg>
            Back
        </a>
        <div class="bookmark-info">
            <h1>{{ .Title }}</h1>
            <div class="original-url">
                Original: <a href="{{ .URL }}" target="_blank" rel="noopener">{{ .URL }}</a>
            </div>
        </div>
        {{ template "nav" . }}
    </nav>
    <iframe class="viewer-frame" src="{{ .RawURL }}" sandbox="allow-same-origin allow-scripts"></iframe>
</body>
</html>
</file>

<file path="internal/core/web/server.go">
package web

import (
	"embed"
	"html/template"
	"io/fs"
	"log"
	"net/http"

	"github.com/seckatie/bookmarkd/internal/core/db"
)

//go:embed templates/*.html static/*.css
var templatesFS embed.FS

type Server struct {
	db                 *db.DB
	templates          *template.Template
	staticFS           http.FileSystem
}

func StartServer(addr string, database *db.DB) {
	ws, err := newServer(database)
	if err != nil {
		log.Fatalf("Failed to initialize web server: %v", err)
	}

	mux := http.NewServeMux()
	ws.registerRoutes(mux)

	log.Printf("Starting web server at %s", addr)
	if err := http.ListenAndServe(addr, mux); err != nil {
		log.Fatalf("Web server failed: %v", err)
	}
}

func newServer(database *db.DB) (*Server, error) {
	templates, err := template.ParseFS(templatesFS, "templates/*.html")
	if err != nil {
		return nil, err
	}

	staticSub, err := fs.Sub(templatesFS, "static")
	if err != nil {
		return nil, err
	}

	return &Server{
		db:        database,
		templates: templates,
		staticFS:  http.FS(staticSub),
	}, nil
}

func (ws *Server) registerRoutes(mux *http.ServeMux) {
	ws.registerStaticRoutes(mux)

	mux.HandleFunc("/", ws.handleIndex)
	mux.HandleFunc("/bookmarklet/add", ws.handleBookmarkletAdd)
	mux.HandleFunc("/bookmarklet", ws.handleBookmarklet)
	mux.HandleFunc("/bookmarks", ws.handleBookmarks)
	mux.HandleFunc("/bookmarks/", ws.handleArchive) // Handles /bookmarks/{id}/archive and /bookmarks/{id}/archive/raw
	mux.HandleFunc("/archives", ws.handleArchiveManager)
	mux.HandleFunc("/archives/", ws.handleArchivesRoutes) // Handles /archives/list and /archives/{id}/refetch
}

func (ws *Server) registerStaticRoutes(mux *http.ServeMux) {
	// Serve embedded static assets (CSS, etc)
	mux.Handle("/static/", http.StripPrefix("/static/", http.FileServer(ws.staticFS)))
}
</file>

<file path="internal/core/web/handlers.go">
package web

import (
	"log"
	"net/http"
)

// renderTemplate renders a template with the standard HTML content-type header.
// If template execution fails, it logs the error and returns a 500 response.
func (ws *Server) renderTemplate(w http.ResponseWriter, templateName string, data any) {
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	if err := ws.templates.ExecuteTemplate(w, templateName, data); err != nil {
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		log.Printf("Failed to execute %s template: %v", templateName, err)
	}
}

// requireMethod checks if the request method matches the expected method.
// Returns true if the method matches, false otherwise (and sends 405 response).
func requireMethod(w http.ResponseWriter, r *http.Request, method string) bool {
	if r.Method != method {
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		return false
	}
	return true
}
</file>

</files>
